### **2023**/10/08

|          | 飞凌ls1046ardb               | nxp ls1046afrwy              | 自研ls1046                   |
| -------- | ---------------------------- | ---------------------------- | ---------------------------- |
| sdk版本  | lsdk1806                     | lsdk1906                     | lsdk1906                     |
| serdes   | 1133-5a59                    |                              | 3333-5559                    |
| 更新方式 | sd更新uboot、U盘更新其他     | 系统镜像烧录sd卡             | 系统镜像烧录sd卡             |
| 使用工具 | flex-builder、flex-installer | flex-builder、flex-installer | flex-builder、flex-installer |
|          |                              | F104S8A(QSGMII PHY)          |                              |

nxp ls1046afrwy：根据`Layerscape FRWY-LS1046A Board Reference Manual.pdf`第7页，内容如下

SerDes1:

• Lane 2: Supports a QSGMII PHY, provides four 1.25 GbE ports

SerDes2:

• Lane 1: Supports a PCIe x1 (Gen 1/2/3) M.2 Key-E slot for 1630/2230 Wi-Fi module

• Lane 3: Supports a PCIe x1 (Gen 1/2/3) M.2 Key-E slot for 1630/2230 Wi-Fi module

其他的lane为Unused

结合`LS1046A Reference Manual.pdf`第1916页，推断出ls1046afrwy的==serdes1可以为1040/2040/3040，serdes2可以为5506/0506==

自研ls1046的两个RGMII不由serdes控制，SGRMII为serdes控制

ls1046afrwy的QSGMII初始化的uboot源码路径如下：u-boot\board\freescale\ls1046afrwy\eth.c

```
fm_info_set_phy_address(FM1_DTSEC6, QSGMII_PORT1_PHY_ADDR);
fm_info_set_phy_address(FM1_DTSEC5, QSGMII_PORT2_PHY_ADDR);
fm_info_set_phy_address(FM1_DTSEC10, QSGMII_PORT3_PHY_ADDR);
fm_info_set_phy_address(FM1_DTSEC1, QSGMII_PORT4_PHY_ADDR);
```

### 2023/10/09

#### 固化到qspi flash

步骤如下，来自LSDK手册，为之后的flash烧录做记录：

**Flash low-level firmware to boot device**

Follow these steps to flash low-level firmware (QSPI firmware / SD card firmware) to boot device (QSPI NOR flash memory / SDcard) on the FRWY-LS1046A board:

1. Remove the SD card from the Linux machine and insert it into the board.
2. Boot the board and stop at U-Boot by pressing **Enter**.
3. Run the following commands to flash QSPI firmware to QSPI NOR flash memory:

```
$ ext2load mmc 0:3 0xa0000000 firmware_ls1046afrwy_uboot_qspiboot.img
$ sf probe
$ sf erase 0x0 +$filesize
$ sf write 0xa0000000 0x0 $filesize
$ reset 
//ext2load从mmc 0:3中加载firmware_ls1046afrwy_uboot_qspiboot.img到0xa0000000
//sf probe识别和初始化连接到 SPI 总线上的 Flash 设备
//sf erase从 `0x0` 处开始擦除长度为 `$filesize` 的区域，即删除了 Flash 存储器中之前的固件
//sf write从0xa0000000加载固件并将新固件从0x0写入，写入的数据的大小为$filesize
```

4. Run the following commands to flash SD card firmware to SD card:

```
$ sudo su
$ chmod 0777 flex-installer
$ sudo ./flex-installer -b bootpartition_LS_arm64_edgescale_lts_4.19_202002251408.tgz
-f firmware_ls1046afrwy_uboot_sdboot.img -r rootfs_v4.0.5.2.tgz -m ls1046afrwy -d /dev/
mmcblk0 
```

制作镜像重点查看lsdk参考手册的**`4.3 How to build LSDK with Flexbuild`**这一章

使用flex-builder制作镜像，使用flex-installer部署镜像到sd卡

> How to automatically build LSDK
> Generally, users can directly deploy the prebuilt LSDK composite firmware and distro userland into storage device on target
> board by flex-installer, in case you want to build custom images with different configurations instead of the default settings, for
> example, you can specify different rcw_<boottype> in <flexbuild_dir>/configs/board/<machine>/manifest to replace the default
> RCW, you can modify source code of various components (RCW, U-Boot, ATF, linux, app components, etc) or choose different
> branch/tag of components by setting <component>_repo_branch or <component>_repo_tag in <flexbuild_dir>/configs/
> build_lsdk.cfg if necessary, finally, you can run the following command to automatically build LSDK in single command.

全部制作

```
flex-builder -m ls1046afrwy 
```

#### 制作fireware

```
flex-builder -i mkfw -m ls1046afrwy -b sd
```

主要的打印信息

```
root@ubuntu:/home/forlinx/nxp/flexbuild_lsdk1906#  flex-builder -i mkfw -m ls1046afrwy -b sd
INSTRUCTION: mkfw
MACHINE: ls1046afrwy
BOOTTYPE: sd

.....。忽略相关依赖安装信息

COMPONENT: atf
MACHINE: ls1046afrwy
BOOTTYPE: sd
make: Entering directory '/home/forlinx/nxp/flexbuild_lsdk1906'
make[1]: Entering directory '/home/forlinx/nxp/flexbuild_lsdk1906/packages/firmware'

......

/home/forlinx/nxp/flexbuild_lsdk1906/build/images/firmware_ls1046afrwy_uboot_qspiboot_secure.img   [Done]
/home/forlinx/nxp/flexbuild_lsdk1906/build/images/bootpartition_LS_arm64_lts_4.14_202310091839.tgz     [Done]
```

远程下载source.codeaurora.org网站的源码失败，ubuntu上配置git以及ssh密钥，使用github的链接下载，

修改`flexbuild_lsdk1906/configs/build_lsdk.cfg`文件中的atf等链接，如下

```
#atf_repo_url=https://source.codeaurora.org/external/qoriq/qoriq-components/atf.git
atf_repo_url=ssh://git@ssh.github.com:443/nxp-qoriq/atf.git
```

下载成功如下：

```
Building ATF ... 
Cloning into 'atf'...
remote: Enumerating objects: 121467, done.
remote: Counting objects: 100% (46656/46656), done.
remote: Compressing objects: 100% (14895/14895), done.
remote: Total 121467 (delta 30782), reused 44670 (delta 30014), pack-reused 74811
Receiving objects: 100% (121467/121467), 26.12 MiB | 4.47 MiB/s, done.
Resolving deltas: 100% (83613/83613), done.
Checking out files: 100% (3800/3800), done.
Switched to a new branch 'LSDK-19.06'
/home/forlinx/nxp/flexbuild_lsdk1906/packages/firmware
```

其他的比如uboot的链接依次设置

编译linux内核打印信息

```
COMPONENT: linux
DESTARCH: arm64
PORTFOLIO: LS
CONFIGLIST: build_lsdk.cfg
make: Entering directory '/home/forlinx/nxp/flexbuild_lsdk1906'
make[1]: Entering directory '/home/forlinx/nxp/flexbuild_lsdk1906/packages/linux'
 Building linux with LSDK-19.06-V4.19 
 KERNEL_CFG = defconfig lsdk.config 
 Compiler = aarch64-linux-gnu-gcc (Ubuntu/Linaro 7.3.0-27ubuntu1~18.04) 7.3.0 
......忽略中间打印信息
Build linux LSDK-19.06-V4.14 in /home/forlinx/nxp/flexbuild_lsdk1906/build/linux/linux/arm64/LS  [Done]
```

```
 sign image for ls1046afrwy qspiboot     [Done]
```

编译根文件系统信息

```
flex-builder -i mkrfs  -m ls1046afrwy
```

```
INSTRUCTION: mkrfs
DISTRO TYPE: ubuntu
DISTRO SCALE: main
DESTARCH: arm64
PORTFOLIO: layerscape
CONFIGLIST: build_lsdk.cfg
generating /home/forlinx/nxp/flexbuild_lsdk1906/build/rfs/rootfs_lsdk1906_LS_arm64_main ...
building /home/forlinx/nxp/flexbuild_lsdk1906/build/rfs/rootfs_lsdk1906_LS_arm64_main ...
additional packages list: /home/forlinx/nxp/flexbuild_lsdk1906/configs/ubuntu/additional_packages_list

INSTRUCTION: mkrfs
MACHINE: ls1046afrwy
generating /home/forlinx/nxp/flexbuild_lsdk1906/build/rfs/rootfs_lsdk1906_LS_arm64_main ...
building /home/forlinx/nxp/flexbuild_lsdk1906/build/rfs/rootfs_lsdk1906_LS_arm64_main ...
additional packages list: /home/forlinx/nxp/flexbuild_lsdk1906/configs/ubuntu/additional_packages_list
```

中间additional_packages_list下载完成后下一阶段信息

```
I: Base system installed successfully.
configure ... 
Adding user user to group sudo
Enter new UNIX password: Retype new UNIX password: passwd: password updated successfully
Enter new UNIX password: Retype new UNIX password: passwd: password updated successfully
Get:1 http://ports.ubuntu.com/ubuntu-ports bionic-security InRelease [88.7 kB]
Get:2 http://us.ports.ubuntu.com/ubuntu-ports bionic InRelease [242 kB]                
Get:3 http://ports.ubuntu.com/ubuntu-ports bionic-security/main arm64 Packages [1559 kB]
Get:4 http://us.ports.ubuntu.com/ubuntu-ports bionic-updates InRelease [88.7 kB]  
Get:5 http://us.ports.ubuntu.com/ubuntu-ports bionic/main arm64 Packages [975 kB]           
Get:6 http://us.ports.ubuntu.com/ubuntu-ports bionic/main Translation-en [516 kB]                Get:7 http://us.ports.ubuntu.com/ubuntu-ports bionic-updates/main arm64 Packages [1845 kB]       Get:8 http://us.ports.ubuntu.com/ubuntu-ports bionic-updates/main Translation-en [553 kB]        Get:9 http://ports.ubuntu.com/ubuntu-ports bionic-security/main Translation-en [467 kB]         Fetched 6334 kB in 18s (358 kB/s)                                                            Reading package lists... Done
dpkg-query: no packages found matching language-pack-en-base
installing language-pack-en-base ..
Reading package lists... Done
Building dependency tree... Done
```

报错

```
Setting up rsyslog (8.32.0-1ubuntu4.2) ...
The user `syslog' is already a member of `adm'.
dpkg: error processing package rsyslog (--configure):
 installed rsyslog package post-installation script subprocess returned error exit status 1
......
Running hooks in /etc/ca-certificates/update.d...
done.
Errors were encountered while processing:
 rsyslog
E: Sub-process /usr/bin/dpkg returned an error code (1)
```

RFSDIR为如下

```
if [ $DISTROTYPE = ubuntu -o $DISTROTYPE = debian ]; then
    if [ $hostarch = aarch64 -o $hostarch = armv7l ] && [ -f /etc/buildinfo ]; then
	RFSDIR=/; DESTDIR=/
    else
	[ $CONFIG_APP_EDGESCALE = y ] && DISTROSCALE=edgescale
	[ $CONFIG_APP_OPENSTACK_NOVA = y ] && DISTROSCALE=cloud
	[ $DISTROTYPE = ubuntu ] && RFSDIR=$FBDIR/build/rfs/rootfs_${DISTRIB_VERSION}_${SOCFAMILY}_${DESTARCH}_$DISTROSCALE || \
	RFSDIR=$FBDIR/build/rfs/rootfs_${DISTROTYPE}_${CODENAME}_${SOCFAMILY}_${DESTARCH}_$DISTROSCALE
    fi
```

流程

  flex-builder -i mkrfs -r ubuntu ...

  flex-builder -i merge-component ... 

  flex-builder -i packrfs ...

DISTROTYPE

### 2023/10/10

`rsyslog` 是一个日志记录守护程序，用于管理系统日志事件的记录和传输。而且不在additional_packages_list内，推断是其他软件包相关的依赖

==mark==：$DISTROSCALE can be main, lite, devel, edgescale, cloud for various scenario of use cases

使用`chroot`+目录路径命令切换根文件系统

```
chroot /home/forlinx/nxp/flexbuild_lsdk1906/build/rfs/rootfs_lsdk1906_LS_arm64_main
```

在rootfs_lsdk1906_LS_arm64_main根文件系统下直接运行安装rsyslog

同样是该问题，复现成功

```
root@ubuntu:/usr# apt-get install rsyslog
Reading package lists... Done
Building dependency tree       
Reading state information... Done
rsyslog is already the newest version (8.32.0-1ubuntu4.2).
0 upgraded, 0 newly installed, 0 to remove and 5 not upgraded.
1 not fully installed or removed.
After this operation, 0 B of additional disk space will be used.
Do you want to continue? [Y/n] y
E: Can not write log (Is /dev/pts mounted?) - posix_openpt (19: No such device)
Setting up rsyslog (8.32.0-1ubuntu4.2) ...
The user `syslog' is already a member of `adm'.
dpkg: error processing package rsyslog (--configure):
 installed rsyslog package post-installation script subprocess returned error exit status 1
Errors were encountered while processing:
 rsyslog
E: Sub-process /usr/bin/dpkg returned an error code (1)
```

有同样的人遇到这个问题，属于nxp的镜像制作工具出现的问题

[ls1043a flexbuild_lsdk1806 build error - NXP Community](https://community.nxp.com/t5/QorIQ/ls1043a-flexbuild-lsdk1806-build-error/m-p/1527267#M11130)

解决方式如下：

```
+++ b/tools/flex-mkdistrorfs
@@ -203,11 +203,12 @@ do_distrorfs_second_stage() {
            apt -y install language-pack-en-base
        fi
     fi
-    apt -y upgrade

     test -f /proc/uptime || mount -t proc proc /proc
     test -f /dev/pts/ptmx || mount -t devpts devpts /dev/pts
+    apt -y upgrade
```

即是将`apt-get -y upgrade`移动test到下方，然后执行清理并重新构建

```
$ flex-builder -i clean-rfs
$ flex-builder -i mkrfs
```

有时候可能因为网络问题导致下载包失败，如下：

```
I: Retrieving libc6 2.27-3ubuntu1
W: Couldn't download package libc6 (ver 2.27-3ubuntu1 arch arm64)
I: Retrieving libcap-ng0 0.7.7-3.1
W: Couldn't download package libcap-ng0 (ver 0.7.7-3.1 arch arm64)
```

重新执行构建命令即可，在lsdk1806中flex-mkdistrorfs工具为1.1版本，没有出现这个问题，而lsdk1906中flex-mkdistrorfs工具为1.2版本

构建过程中不要误按`ctrl+C`，因为flex-builder这个工具每次在执行根文件系统制作目录时，检测到原目录存在文件时，会直接先自动清空该目录，相当于每一次构建根文件系统都是从零开始，不会断点续连:cry:，在清楚是否应该清空目录的情况下可以注释这行代码`[ -n "$RFSDIR" ] && sudo rm -rf $RFSDIR/*`，不过还是需要重新下载，只是避开了无法删除跟`/dev/pts/ptmx`相关的报错问题

#### 制作根文件系统

完成打印信息

```
Fetched 142 kB in 12s (12.0 kB/s) 
Selecting previously unselected package libparted2:arm64.
(Reading database ... 37443 files and directories currently installed.)
Preparing to unpack .../libparted2_3.2-20ubuntu0.2_arm64.deb ...
Unpacking libparted2:arm64 (3.2-20ubuntu0.2) ...
Selecting previously unselected package parted.
Preparing to unpack .../parted_3.2-20ubuntu0.2_arm64.deb ...
Unpacking parted (3.2-20ubuntu0.2) ...
Setting up libparted2:arm64 (3.2-20ubuntu0.2) ...
Setting up parted (3.2-20ubuntu0.2) ...
Processing triggers for man-db (2.8.3-2ubuntu0.1) ...
qemu: Unsupported syscall: 277
Processing triggers for libc-bin (2.27-3ubuntu1.6) ...
installed additional packages.
Get:1 http://ports.ubuntu.com/ubuntu-ports bionic-security InRelease [88.7 kB]
Hit:2 http://us.ports.ubuntu.com/ubuntu-ports bionic InRelease                              
Get:3 http://us.ports.ubuntu.com/ubuntu-ports bionic-updates InRelease [88.7 kB]
Get:4 http://us.ports.ubuntu.com/ubuntu-ports bionic/universe arm64 Packages [8,316 kB]         Get:5 http://us.ports.ubuntu.com/ubuntu-ports bionic/universe Translation-en [4,941 kB]         Get:6 http://us.ports.ubuntu.com/ubuntu-ports bionic/multiverse arm64 Packages [126 kB]         Get:7 http://us.ports.ubuntu.com/ubuntu-ports bionic/multiverse Translation-en [108 kB]         Get:8 http://us.ports.ubuntu.com/ubuntu-ports bionic-updates/universe arm64 Packages [1,718 kB] Get:9 http://us.ports.ubuntu.com/ubuntu-ports bionic-updates/universe Translation-en [421 kB]   Get:10 http://us.ports.ubuntu.com/ubuntu-ports bionic-updates/multiverse arm64 Packages [4,948 B] et:11 http://us.ports.ubuntu.com/ubuntu-ports bionic-updates/multiverse Translation-en [6,088 B]                                                                                   
Fetched 15.8 MB in 16s (987 kB/s)                                                               Reading package lists... Done
WARNING: apt does not have a stable CLI interface. Use with caution in scripts.
ARNING: apt does not have a stable CLI interface. Use with caution in scripts.
 /home/forlinx/nxp/flexbuild_lsdk1906/build/rfs/rootfs_lsdk1906_LS_arm64_main     [Done] 
```

### 2023/10/11

#### 配置内核

```
flex-builder -c linux:custom -m ls1046afrwy -a arm64
```

#### 单独编译内核

```
flex-builder -c linux -a arm64 -m ls1046afrwy
```

#### 生成arm64上使用的bootpartition

```
flex-builder -i mkbootpartition -a arm64 -m ls1046afrwy
```

#### 单独更新设备树

```
cp  build/linux/linux/arm64/LS/output/master/arch/arm64/boot/dts/freescale/fsl-ls1046a-frwy* /home/forlinx/nxp/flexbuild_lsdk1906/build/images/bootpartition_LS_arm64_lts_4.14
```

#### DTB转DTS

```
/usr/bin/dtc -O dts -I dtb -o fsl-ls1046a-frwy-sdk.dts fsl-ls1046a-frwy-sdk.dtb
```

#### 制作app

命令如下，必须保持网络正常通信

```
flex-builder -c apps
```

制作完成打印信息

```
Build apps components  [Done] 
make[1]: Leaving directory '/home/forlinx/nxp/flexbuild_lsdk1906/packages/apps'
make: Leaving directory '/home/forlinx/nxp/flexbuild_lsdk1906'
```

#### 合并app以及kernel modules到rootfs

```
root@ubuntu:/home/forlinx/nxp/flexbuild_lsdk1906# flex-builder -i merge-component
INSTRUCTION: merge-component
 merge kernel modules and apps components into /home/forlinx/nxp/flexbuild_lsdk1906/build/rfs/rootfs_lsdk1906_LS_arm64_main     [Done]
```

#### 打包压缩rootfs

```
root@ubuntu:/home/forlinx/nxp/flexbuild_lsdk1906#  flex-builder -i packrfs
INSTRUCTION: packrfs
packing rootfs_lsdk1906_LS_arm64_main_202310101848.tgz, waiting ...
/home/forlinx/nxp/flexbuild_lsdk1906/build/images/rootfs_lsdk1906_LS_arm64_main_202310101848.tgz     [Done] 
```

#### 烧录到sd卡

格式化

```
flex-installer -i pf -d /dev/sdb
```

进入/build/images目录，执行以下命令，注意这个已经覆盖了烧录firmware

```
flex-installer  -b bootpartition_LS_arm64_lts_4.14.tgz -r rootfs_lsdk1906_LS_arm64_main.tgz  -f firmware_ls1046afrwy_uboot_sdboot.img -m ls1046afrwy -d /dev/sdb
```

单独烧录firmware

```
flex-installer  -f firmware_ls1046afrwy_uboot_sdboot.img -m ls1046afrwy -d /dev/sdb
```

烧录过程相关打印信息如下：

```
WARNING: Appears /mnt/sdb4 contains an existing file system, formatting this partition might cause loss of data on it 
Do you want to format this partition now? [y/n] y
 Partitioning /dev/sdb ... 
 Formatting partitions ... 
/dev/sdb1 contains a ext4 file system labelled 'misc'
	last mounted on Tue Oct 10 19:01:04 2023
/dev/sdb2 contains a ext4 file system labelled 'boot'
	last mounted on /media/forlinx/boot on Tue Oct 10 19:01:04 2023
/dev/sdb3 contains a ext4 file system labelled 'backup'
	last mounted on Tue Oct 10 19:01:03 2023
/dev/sdb4 contains a ext4 file system labelled 'system'
	last mounted on /media/forlinx/system on Tue Oct 10 19:01:08 2023
Model: Mass Storage Device (scsi)
Disk /dev/sdb: 31.9GB
Sector size (logical/physical): 512B/512B
Partition Table: msdos
Disk Flags: 

Number  Start   End     Size    Type     File system  Flags
 1      71.3MB  176MB   105MB   primary  ext4
 2      177MB   1251MB  1074MB  primary  ext4
 3      1252MB  7694MB  6442MB  primary  ext4
 4      7695MB  31.9GB  24.2GB  primary  ext4

 partition and format /dev/sdb     [Done] 
Installing boot partition, please wait ...
 boot partition installation     [Done] 
Installing system partition, please wait ...
 system partition installation     [Done] 
sync data, please wait ...
setting PARTUUID ...
 Installation completed successfully 
```

#### 启动准备

1. 注意板卡上的拨码开关的位置为213，有三块，每块有四个拨码，设置拨码的时候要从第二块开始设置，然后是第一块，最后是第三块

2. > **SW1[1:9]=> CFG_RCW_SRC[0:8]**
   >
   > **## 0_0100_0100 (Quad SPI) – default**
   >
   > **## 0_0100_0000 (eSDHC)**
   >
   > **## 1_0000_01xx (8-bit NAND , 2 KB page, 64 pages/block) [LS1043 only)\**\***
   >
   > **## 0_1001_1110 (0x9E - Hard-Coded RCW)**
   >
   > **Note:: LS1046A do not support booting from NAND flash**
   >
   > **SW1[10]=> CFG_ENG_USE0**
   >
   > **# 0 DIFF_SYSCLK/DIFF_SYSCLK_B (differential)-> 100MHz (Fixed) – default**
   >
   > **# 1 SYSCLK (single ended)-> 100MHz (Fixed)**

根据以上信息设置拨码开关

#### 上电启动

部分信息如下：

```
NOTICE:  Fixed DDR on board
NOTICE:  4 GB DDR4, 64-bit, CL=15, ECC on
NOTICE:  BL2: v1.5(release):LSDK-19.06
NOTICE:  BL2: Built : 19:48:30, Oct  9 2023
NOTICE:  BL2: Booting BL31
NOTICE:  BL31: v1.5(release):LSDK-19.06
NOTICE:  BL31: Built : 19:48:35, Oct  9 2023
NOTICE:  Welcome to LS1046 BL31 Phase

U-Boot 2019.04 (Oct 09 2023 - 00:45:44 -0700)
```

由`Oct 09 2023`看出，是自行编译生成的img镜像烧录启动的，自此，lsdk1906的环境搭建完毕，之后开始源码分析及适配自研的外设。

#### 将当前uboot和kernel代码推到github，用git管理

先在github上创建远程仓库

拉取uboot的源代码并且切换分支后，按以下步骤执行

```shell
//先删除uboot原本的`.git`文件
rm -rf .git 
//初始化本地仓库
git init
//拉取uboot远程github仓库
git pull ssh://git@ssh.github.com:443/findyang/u-boot.git
//配置新的origin
git remote add origin  ssh://git@ssh.github.com:443/findyang/u-boot.git
//将当前目录的文件存入暂存区
git add .
//提交代码
git commit -m "init u-boot-19.04 of LSDk1906"
//推送代码
git push origin master
//重新拉取更新
git pull
//如果出现以下信息
//There is no tracking information for the current branch.
//Please specify which branch you want to merge with.
//则执行以下命令
git branch --set-upstream-to=origin/master
```

在github将main分支切换到master作为`Default branch`，然后删除main分支

- 在对应仓库页面，点击settings，将Default branch更改回master
- 回到code页面，点击branch，删除master以外的其他分支

同样操作对内核代码提交

```shell
//先删除uboot原本的`.git`文件
rm -rf .git 
//初始化本地仓库
git init
//注意：选择linux kernel 远程github仓库
git pull ssh://git@ssh.github.com:443/findyang/linux.git
//配置新的origin
git remote add origin  ssh://git@ssh.github.com:443/findyang/linux.git
//将当前目录的文件存入暂存区
git add .
//提交代码
git commit -m "init linux-4.14 of LSDk1906"
//推送代码
git push origin master
//重新拉取更新
git pull
//如果出现以下信息
//There is no tracking information for the current branch.
//Please specify which branch you want to merge with.
//则执行以下命令
git branch --set-upstream-to=origin/master
```

其余同上uboot操作

### 2023/10/12-14

serdes配置

当前需要配置成`3333-5559`

[干货丨LS1046A&LS1028A平台的SerDes设计方案 - 飞凌嵌入式行业资讯 - 保定飞凌嵌入式技术有限公司 (forlinx.com)](https://www.forlinx.com/article_view_551.html)

[LS104x网口RCW及网口配置修改示例_serdes uboot_kunkliu的博客-CSDN博客](https://blog.csdn.net/kunkliu/article/details/116525967)

修改RCW

由于LS104x系列开发板引入了【复位控制字】Reset configuration word (RCW)的配置方法，通过这种配置方法可以方便的进行引脚的功能定义，也就是实现引脚的PinMUX功能。

LS104x平台所特有的SerDes Module也是要通过RCW来进行配置，从而将不同的SerDes通道选择为不同的功能。

#### 第一步：修改RCW配置

为了开发方便，先从1046ardb拷贝一份1333_5559文件夹下的rcw_1800_sdboot.rcw

首先修改RCW配置为3333_5559，分别修改SRDS_PRTCL_S1和SRDS_PRTCL_S2的值，此处要将16进制转化为10进制换算，如0x3333的十进制为13107，0x5559的十进制为21849。

根据命名约定：

|             | 自研ls1046            |      |
| ----------- | --------------------- | ---- |
| 文件夹      | RR_SSSSPPPH_3333_5559 |      |
| PLL mapping | 2222-2221             |      |
|             |                       |      |

暂时修改后的内容如下，之后发现问题再进行修改

```
/*
 * LS1046AFRWY RCW for SerDes Protocol 0x3040_0x0506
 *
 * 4G configuration -- 4G QSGMII + 2 PCIe
 *
 * Frequencies:
 *
 * Sys Clock: 100 MHz
 * DDR_Refclock: 100 MHz
 *
 * Core		-- 1600 MHz (Mul 16)
 * Platform	-- 600 MHz (Mul 6)
 * DDR		-- 2100 MT/s (Mul 21)
 * FMan		-- 700 MHz (CGA2 /2)
 * QSGMII	-- 100 MHz (5G)
 * PCIE		-- 100 MHz (5G)
 * eSDHC	-- 1400 MHz (CGA2 /1)
 *
 * Hardware Accelerator Block Cluster Group A Mux Clock:
 *   FMan        - HWA_CGA_M1_CLK_SEL = 6 - Async mode, CGA PLL 2 /2 is clock
 *   eSDHC, QSPI - HWA_CGA_M2_CLK_SEL = 1 - Async mode, CGA PLL 2 /1 is clock
 *
 * Serdes Lanes vs Slot information
 * Serdes Lanes vs Slot information
 *  Serdes1 Lane 0 (D) - Unused
 *  Serdes1 Lane 1 (C) - Unused
 *  Serdes1 Lane 2 (B) - QSGMII6,QSGMII5,QSGMII10,QSGMII1 port
 *  Serdes1 Lane 3 (A) - Unused
 *
 *  Serdes2 Lane 0 (A) - Unused
 *  Serdes2 Lane 1 (B) - PCIe2 Gen3 x1
 *  Serdes2 Lane 2 (C) - Unused
 *  Serdes2 Lane 3 (D) - PCIe3 Gen3 x1
 *
 * PLL mapping: 2222_2222
 *
 * Serdes 1:
 *  PLL mapping: 2222
 *
 *  SRDS_PLL_REF_CLK_SEL_S1 : 0b'01
 *    SerDes 1, PLL1[160] : 0 - 100MHz for QSGMII
 *    SerDes 1, PLL2[161] : 1 - 100MHz for QSGMII
 *  SRDS_PLL_PD_S1 : 0b'0
 *    SerDes 1, PLL1 : 0 - not power down
 *    SerDes 1, PLL2 : 0 - not poewr down
 *  HWA_CGA_M1_CLK_SEL[224-226] : 6 - Cluster Group A PLL 2 /2 to FMan
 *
 * Serdes 2:
 *  PLL mapping: 2222
 *  SRDS_PLL_REF_CLK_SEL_S2 : 0b'00
 *    SerDes 2, PLL1[162] : 0 - 100MHz for PCIe
 *    SerDes 2, PLL2[163] : 0 - 100MHz for PCIe
 *  SRDS_PLL_PD_S2 : 0b'00
 *    SerDes 2, PLL1 : 0 - not power down
 *    SerDes 2, PLL2 : 0 - not poewr down
 *  SRDS_DIV_PEX_S2 : 0b'01
 *    00 - train up to max rate of 8G
 *    01 - train up to max rate of 5G
 *    10 - train up to max rate of 2.5G
 *
 * DDR clock:
 * DDR_REFCLK_SEL : 1 - DDRCLK pin provides the reference clock to the DDR PLL
 *
 */

#include <../ls1046ardb/ls1046a.rcwi>

SYS_PLL_RAT=6
MEM_PLL_RAT=21
CGA_PLL1_RAT=16
CGA_PLL2_RAT=14
SRDS_PRTCL_S1=12352
SRDS_PRTCL_S2=1286
SRDS_PLL_PD_S1=2
DDR_REFCLK_SEL=1
DDR_FDBK_MULT=2
PBI_SRC=6
IFC_MODE=64
HWA_CGA_M1_CLK_SEL=6
DRAM_LAT=1
UART_BASE=7
IRQ_OUT=1
IFC_GRP_A_EXT=1
IFC_GRP_E1_EXT=2
IFC_GRP_F_EXT=1
IFC_GRP_D_BASE=1
EC1=1
EC2=1
TVDD_VSEL=1
DVDD_VSEL=2
EVDD_VSEL=2
IIC2_EXT=1
SYSCLK_FREQ=600
HWA_CGA_M2_CLK_SEL=1

.pbi
// set boot location ptr
write 0x570600, 0x00000000
write 0x570604, 0x10000000
.end

// Errta A-008850 for ddr controller for barrier transaction
#include <../ls1046ardb/cci_barrier_disable.rcw>
// Set USB PHY PLL for 100MHz
#include <../ls1046ardb/usb_phy_freq.rcw>
// Clear SerDes RxBoost on SD2 lane D
#include <../ls1046ardb/serdes_sata.rcw>
// Errata A-010477 and  A-008851 for PCI Express Gen3 link training
#include <../ls1046ardb/pex_gen3_link.rcw>

.pbi
// Software must wait after updating the ALTCBAR.
// Below is the PBL Wait command (0xc0)
write 0x6100c0, 0x000fffff
.end
```

先修改源码使用新的bin文件，源码路径如下：

`/home/forlinx/nxp/flexbuild_lsdk1906/configs/board/ls1046afrwy/manifest`

修改内容如下：

```diff
-rcw_sd=build/firmware/rcw/ls1046afrwy/NN_NNQNNPNP_3040_0506/rcw_1600_sdboot.bin
+rcw_sd=build/firmware/rcw/ls1046afrwy/RR_SSSSPPPH_3333_5559/rcw_1800_sdboot.bin
```

编译测试rcw是否添加成功，然后重新生成firmware

```
flex-builder -i mkfw -m ls1046afrwy -b sd
```

结果如下：

 Build RCW  成功

```
Building RCW ... 
make[3]: Entering directory '/home/forlinx/nxp/flexbuild_lsdk1906/packages/firmware/rcw/ls1046afrwy'
python2 ../rcw.py -i RR_SSSSPPPH_3333_5559/rcw_1800_sdboot.rcw -o RR_SSSSPPPH_3333_5559/rcw_1800_sdboot.bin
/home/forlinx/nxp/flexbuild_lsdk1906/packages/firmware/rcw/ls1046afrwy/../qspi_swap.sh /home/forlinx/nxp/flexbuild_lsdk1906/packages/firmware/rcw/ls1046afrwy/../qspi_swap_list.txt
make[3]: Leaving directory '/home/forlinx/nxp/flexbuild_lsdk1906/packages/firmware/rcw/ls1046afrwy'
make[3]: Entering directory '/home/forlinx/nxp/flexbuild_lsdk1906/packages/firmware/rcw/ls1046afrwy'
install -d /home/forlinx/nxp/flexbuild_lsdk1906/build/firmware/rcw/ls1046afrwy
install -m 644 -D README /home/forlinx/nxp/flexbuild_lsdk1906/build/firmware/rcw/ls1046afrwy
make[3]: Leaving directory '/home/forlinx/nxp/flexbuild_lsdk1906/packages/firmware/rcw/ls1046afrwy'
 Build RCW  [Done]
```

重新生成镜像成功

```
/home/forlinx/nxp/flexbuild_lsdk1906/build/images/firmware_ls1046afrwy_uboot_sdboot.img   [Done]
```

烧录测试当前效果，参考如下链接：

[跳转烧录步骤](###烧录到sd卡)

单独烧录firmware命令

```
flex-installer   -f firmware_ls1046afrwy_uboot_sdboot.img -m ls1046afrwy -d /dev/sdb
```

#### 第二步：修改Uboot的网络初始化代码

我们先整理一下我们的项目中PHY与MAC的对应关系：

以下的PHY地址是来源于原理图中，MDIO这部分的设置，当前使用ADDR[2:0]，即是最多设置8个，比如原理图中RGMII1设置的ADDR[2:0]为001，即是0x1，其余依次类推，最终汇总如下，==这个表格很重要==，后续返回说明：表格中的SGMII及RGMII后面的数字对应错误，该数字应该是serdes配置对应的mac值，详情查看[uboot之有线网口](####uboot之有线网口（未解决）)

| **网络接口** | **PHY地址** ADDR[2:0] | **PHY地址宏定义名称** | **SerDes通道** |
| ------------ | --------------------- | --------------------- | -------------- |
| RGMII1       | 0x1                   | RGMII_PHY1_ADDR       |                |
| RGMII2       | 0x2                   | RGMII_PHY2_ADDR       |                |
| SGMII3       | 0x3                   | SGMII_PHY1_ADDR       | SD1_TX0_P      |
| SGMII4       | 0x4                   | SGMII_PHY2_ADDR       | SD1_TX2_P      |
| SGMII5       | 0x5                   | SGMII_PHY3_ADDR       | SD1_TX3_P      |

先在头文件中添加我们所需的PHY地址的定义，该文件在源码中的位置为：

`flexbuild/packages/firmware/u-boot/include/configs/ls1046afrwy.h`

在板级配置文件中，你可以找到 SGMII_PHY1_ADDR 的定义，通常是以 `#define` 的方式定义。这个值通常会根据硬件设计来确定，例如，如果板上有一个 SGMII 接口连接到一个特定的 PHY 地址，需要在配置文件中将 SGMII_PHY1_ADDR 设置为这个 PHY 地址。

设置如下：红色（"-"号）为需要注释的内容，绿色（"+"号）为需要新增的内容

```diff
-#define QSGMII_PORT1_PHY_ADDR		0x1c
-#define QSGMII_PORT2_PHY_ADDR		0x1d
-#define QSGMII_PORT3_PHY_ADDR		0x1e
-#define QSGMII_PORT4_PHY_ADDR		0x1f
+#define RGMII_PHY1_ADDR                        0x1
+#define RGMII_PHY1_ADDR                        0x2
+#define SGMII_PHY1_ADDR                        0x3
+#define SGMII_PHY2_ADDR                        0x4
+#define SGMII_PHY3_ADDR                        0x5
```

Uboot的网络初始化代码在源码中的位置为：

`flexbuild/packages/firmware/u-boot/board/freescale/ls1046afrwy/ls1046afrwy.c`

然后我们要修改网络部分的配置，路径如下:

`flexbuild/packages/firmware/u-boot/board/freescale/ls1046afrwy/eth.c`

```diff
//注释原有的万兆相关网口
-fm_info_set_phy_address(FM1_DTSEC6, QSGMII_PORT1_PHY_ADDR);
-fm_info_set_phy_address(FM1_DTSEC5, QSGMII_PORT2_PHY_ADDR);
-fm_info_set_phy_address(FM1_DTSEC10, QSGMII_PORT3_PHY_ADDR);
-fm_info_set_phy_address(FM1_DTSEC1, QSGMII_PORT4_PHY_ADDR);
//删除3040的支持，修改为3333的支持
switch (srds_s1) {
-case 0x3040:
+case 0x3333:
+// add gie RGMII
+fm_info_set_phy_address(FM1_DTSEC1, RGMII_PHY1_ADDR);
+fm_info_set_phy_address(FM1_DTSEC2, RGMII_PHY2_ADDR);

+//add gie SGMII
+fm_info_set_phy_address(FM1_DTSEC3, SGMII_PHY1_ADDR);
+fm_info_set_phy_address(FM1_DTSEC4, SGMII_PHY2_ADDR);
+fm_info_set_phy_address(FM1_DTSEC5, SGMII_PHY3_ADDR);
+run_command("setenv serdes1 3333", 0);

//注释原有的万兆相关的对挂载的MAC的注册，增加新ls1046的注册
-fm_info_set_mdio(FM1_DTSEC6, dev);
-fm_info_set_mdio(FM1_DTSEC5, dev);
-fm_info_set_mdio(FM1_DTSEC10, dev);
-fm_info_set_mdio(FM1_DTSEC1, dev);
+fm_info_set_mdio(FM1_DTSEC1, dev);
+fm_info_set_mdio(FM1_DTSEC2, dev);
+fm_info_set_mdio(FM1_DTSEC3, dev);
+fm_info_set_mdio(FM1_DTSEC4, dev);
+fm_info_set_mdio(FM1_DTSEC5, dev);

//fdt_update_ethernet_dt函数增加3333的配置，里面暂时什么都不做
+case 0x3333:
+break;
```

修改完此部分后则Uboot部分对网络配置的代码修改完成。

#### 第三步：修改设备树的网络初始化代码

RCW配置所对应的设备树文件在源码中的位置为：

`packages/linux/linux/arch/arm64/boot/dts/freescale/fsl-ls1046a-frwy-sdk.dts`

注意`fsl-ls1046a-frwy-sdk.dts`包含`fsl-ls1046a-frwy.dts`，所以内容在这两个文件里修改

我们直接在原本的文件上修改，不需要修改Makefile来增加文件支持

修改完成的设备树fman0相关源码如下：

```
&fman0 {
	ethernet@10000 {
		phy-handle = <&rgmii_phy1>;
		phy-connection-type = "rgmii";
	};

	ethernet@20000 {
		phy-handle = <&rgmii_phy2>;
		phy-connection-type = "rgmii";
	};

	ethernet@30000 {
		phy-handle = <&sgmii_phy1>;
		phy-connection-type = "sgmii";
	};

	ethernet@40000 {
		phy-handle = <&sgmii_phy2>;
		phy-connection-type = "sgmii";
	};

	ethernet@50000 {
		phy-handle = <&sgmii_phy3>;
		phy-connection-type = "sgmii";
	};

	mdio@fd000 {
		rgmii_phy1: ethernet-phy@1 {
			reg = <0x1>;
		};

		rgmii_phy2: ethernet-phy@2 {
			reg = <0x2>;
		};

		sgmii_phy1: ethernet-phy@3 {
			reg = <0x3>;
		};

		sgmii_phy2: ethernet-phy@4 {
			reg = <0x4>;
		};

		sgmii_phy3: ethernet-phy@5 {
			reg = <0x5>;
		};
	};
};
```

编译并烧录启动测试，相关信息为

```
Model: LS1046A FRWY Board
Board: LS1046AFRWY, Rev: A, boot from SD
SD1_CLK1 = 100.00MHZ, SD1_CLK2 = 100.00MHZ
I2C:   ready
DRAM:  3.9 GiB (DDR4, 64-bit, CL=15, ECC on)
SEC0: RNG instantiated
PCA: failed to select proper channel
Using SERDES1 Protocol: 13107 (0x3333)
Using SERDES2 Protocol: 21849 (0x5559)
NAND:  512 MiB
MMC:   FSL_SDHC: 0
Loading Environment from MMC... *** Warning - bad CRC, using default environment

EEPROM: Read failed.
In:    serial
Out:   serial
Err:   serial
Net:
MMC read: dev # 0, block # 18432, count 128 ...
Fman1: Uploading microcode version 106.4.18
PCIe0: pcie@3400000 Root Complex: no link
PCIe1: pcie@3500000 Root Complex: no link
PCIe2: pcie@3600000 Root Complex: no link
FM1@DTSEC3 [PRIME]
Error: FM1@DTSEC3 address not set.
, FM1@DTSEC4
Error: FM1@DTSEC4 address not set.
, FM1@DTSEC5
Error: FM1@DTSEC5 address not set.
, FM1@DTSEC6
Error: FM1@DTSEC6 address not set.
, FM1@DTSEC9
Error: FM1@DTSEC9 address not set.
, FM1@DTSEC10
Error: FM1@DTSEC10 address not set.
Hit any key to stop autoboot:  0

=> ping 192.168.0.100
FM1@DTSEC3 Waiting for PHY auto negotiation to complete......... TIMEOUT !
FM1@DTSEC3: Could not initialize
FM1@DTSEC4 Waiting for PHY auto negotiation to complete......... TIMEOUT !
FM1@DTSEC4: Could not initialize
FM1@DTSEC5 Waiting for PHY auto negotiation to complete......... TIMEOUT !
FM1@DTSEC5: Could not initialize
*** ERROR: `eth3addr' not set
ping failed; host 192.168.0.100 is not alive
=>

```

比刚配置3333-5559相比

1. Fman1识别成功
2. 设置了FM1@DTSEC3 [PRIME]，即是DTSEC3 （sgmii 1）为主网口

由于与demo板使用的网口厂家不一样，接下来使能 Realtek 公司的 PHY 驱动

1. 参考`ls1046ardb.h`增加Realtek 公司的 PHY 驱动的宏`#define CONFIG_PHY_REALTEK`

2. 然后`packages/firmware/u-boot/configs/ls1046afrwy_tfa_defconfig`增加`CONFIG_PHY_REALTEK=y`

定位一下`address not set.`产生的位置，路径在

/home/forlinx/nxp/flexbuild_lsdk1906/packages/firmware/u-boot/net/eth_legacy.c/eth_legacy.c

`eth_write_hwaddr`函数

经过测试，网口还是没法完全启用，启动信息如下：

```
FSL_MDIO0:3 is connected to FM1@DTSEC3.  Reconnecting to FM1@DTSEC6
FSL_MDIO0:3 is connected to FM1@DTSEC6.  Reconnecting to FM1@DTSEC9
FSL_MDIO0:3 is connected to FM1@DTSEC9.  Reconnecting to FM1@DTSEC10
```

但是源码中应该只设置了1、2、3、4、5，没有涉及到6、9、10了

先分析以上信息，定位源码路径

/home/forlinx/nxp/flexbuild_lsdk1906/packages/firmware/u-boot/drivers/net/phy/phy.c

==mark==：先解决内核启动并挂载根文件系统的问题，再回来解决这个（10.18已解决内核启动并挂载根文件系统以及等等的其他问题，等待解决网口）

#### 去除没有使用的nand flash相关

先尝试把nand 初始化取消，因为项目中大概率不会使用到nand

使用配置文件defconfig lsdk.config

先在/home/forlinx/nxp/flexbuild_lsdk1906/packages/linux/linux/arch/arm64/configs/defconfig文件中注释与nand相关

```diff
-CONFIG_MTD_NAND=y
-CONFIG_MTD_NAND_DENALI_DT=y
-CONFIG_MTD_NAND_FSL_IFC=y
+CONFIG_MTD_NAND=n
+CONFIG_MTD_NAND_DENALI_DT=n
+CONFIG_MTD_NAND_FSL_IFC=n
```

配置内核

```
flex-builder -c linux:custom -m ls1046afrwy -a arm64
```

单独编译linux kernel

```
flex-builder -c linux -a arm64 -m ls1046afrwy
```

经过测试，上面的是相关驱动程序的加载，不是nand取消初始化相关

### 2023/10/16

> linux kernel启动流程，linux/init/main.c文件下`start_kernel`函数定义
>
> start_kernel() -> setup_arch(&command_line) -> mdesc =
>
> setup_machine(machine_arch_type) -> list = lookup_machine_type(nr)
>
> -> return struct machine_desc.
>
> 内核在启动的时候就是最先运行start_kernel() ,
>
> 然后就会调用体系结构相关的setup_arch(&command_line),
>
> 如arm体系结构的在arch/arm/kernel/setup.c中, 进一步, 就要初始化板级相关的设备,  但在此之前,
>
> 必须找到这块目标板的描述结构, 所以就先通过lookup_machine_type(nr)来查找这个结构,
>
> 传入的参数是又uboot传过来的, 存储在r2中. 

报错信息`Bad eraseblock 0 at 0x000000000000`出自：

/home/forlinx/nxp/flexbuild_lsdk1906/packages/linux/linux/drivers/mtd/nand/nand_bbt.c第454行`create_bbt`函数，参考以下分析

[详细解析UBOOT下NAND BBT的代码流程-CSDN博客](https://blog.csdn.net/record_my_foot/article/details/100174243)

[十七、Linux驱动之nand flash驱动_nand_get_flash_type函数在哪里使用-CSDN博客](https://blog.csdn.net/qq_36576792/article/details/84791465)[十七、Linux驱动之nand flash驱动_nand_get_flash_type函数在哪里使用-CSDN博客](https://blog.csdn.net/qq_36576792/article/details/84791465)

nand flash初始化流程：

fsl_ifc_nand_driver --> fsl_ifc_nand_probe --> nand_scan --> nand_scan_ident --> nand_detect

注释`drivers/mtd/nand/fsl_ifc_nand.c`中以下行，这行代码是一个宏的调用，通常在 Linux 内核模块的代码中使用，用于注册一个平台驱动程序。注意这里是直接把驱动注册注释了，不是把初始化代码注释了，后续又有使用到nand flash相关内容的时候，需要回来打开并解决这个问题。

```
// module_platform_driver(fsl_ifc_nand_driver);
```

编译过程中输出信息，表明使用的是`drivers/mtd/nand/fsl_ifc_nand.o`

```
  CHK     include/config/kernel.release
  CHK     include/generated/uapi/linux/version.h
  GEN     ./Makefile
  CHK     scripts/mod/devicetable-offsets.h
  UPD     include/config/kernel.release
  CHK     include/generated/utsrelease.h
  Using /home/forlinx/nxp/flexbuild_lsdk1906/packages/linux/linux as source for kernel
  UPD     include/generated/utsrelease.h
  CHK     include/generated/timeconst.h
  CHK     include/generated/bounds.h
  CHK     include/generated/asm-offsets.h
  CALL    /home/forlinx/nxp/flexbuild_lsdk1906/packages/linux/linux/scripts/checksyscalls.sh
  CHK     include/generated/compile.h
  CC      init/version.o
  CC      kernel/sys.o
  DTC     arch/arm64/boot/dts/freescale/fsl-ls1043a-rdb-sdk.dtb
  AR      init/built-in.o
  DTC     arch/arm64/boot/dts/freescale/fsl-ls1046a-rdb-sdk.dtb
  DTC     arch/arm64/boot/dts/freescale/fsl-ls2088a-rdb.dtb
  DTC     arch/arm64/boot/dts/freescale/fsl-lx2160a-rdb.dtb
  CC      drivers/base/firmware_class.o
  AR      drivers/base/built-in.o
  CC      kernel/module.o
  CHK     kernel/config_data.h
  AR      kernel/built-in.o
  CC      drivers/mtd/nand/fsl_ifc_nand.o
/home/forlinx/nxp/flexbuild_lsdk1906/packages/linux/linux/drivers/mtd/nand/fsl_ifc_nand.c:1101:31: warning: ‘fsl_ifc_nand_driver’ defined but not used [-Wunused-variable]
 static struct platform_driver fsl_ifc_nand_driver = {
                               ^~~~~~~~~~~~~~~~~~~
  AR      drivers/mtd/nand/built-in.o
  AR      drivers/mtd/built-in.o
  AR      drivers/built-in.o
  GEN     .version
  CHK     include/generated/compile.h
  UPD     include/generated/compile.h
  CC      init/version.o
  AR      init/built-in.o
  AR      built-in.o
```

编译过程的警告信息，暂时没有涉及到ls1046afrwy，但是ls1046afrwy是复用了ls1046ardb的部分代码，也可能存在没有暴露的问题

```
arch/arm64/boot/dts/freescale/fsl-ls1046a-rdb-sdk.dtb: Warning (unit_address_vs_reg): Node /memory@80000000 has a unit name, but no reg property
arch/arm64/boot/dts/freescale/fsl-ls1046a-rdb-sdk.dtb: Warning (unit_address_vs_reg): Node /soc/qman-portals@500000000/qman-fqids@0 has a unit name, but no reg property
arch/arm64/boot/dts/freescale/fsl-ls1046a-rdb-sdk.dtb: Warning (unit_address_vs_reg): Node /soc/bman-portals@508000000/bman-bpids@0 has a unit name, but no reg property
arch/arm64/boot/dts/freescale/fsl-ls1046a-rdb-sdk.dtb: Warning (unit_address_vs_reg): Node /soc/fsl,dpaa/ethernet@0 has a unit name, but no reg property
arch/arm64/boot/dts/freescale/fsl-ls1046a-rdb-sdk.dtb: Warning (unit_address_vs_reg): Node /soc/fsl,dpaa/ethernet@1 has a unit name, but no reg property
arch/arm64/boot/dts/freescale/fsl-ls1046a-rdb-sdk.dtb: Warning (unit_address_vs_reg): Node 
arch/arm64/boot/dts/freescale/fsl-ls1046a-rdb-sdk.dtb: Warning (simple_bus_reg): Node /soc/ifc@1530000/nand@0,0 simple-bus unit address format error, expected "0"
arch/arm64/boot/dts/freescale/fsl-ls1046a-rdb-sdk.dtb: Warning (simple_bus_reg): Node /soc/ifc@1530000/board-control@2,0 simple-bus unit address format error, expected "200000000"
arch/arm64/boot/dts/freescale/fsl-ls1046a-rdb-sdk.dtb: Warning (simple_bus_reg): Node /soc/qman-portals@500000000/qman-fqids@0 missing or empty reg/ranges property
arch/arm64/boot/dts/freescale/fsl-ls1046a-rdb-sdk.dtb: Warning (simple_bus_reg): Node /soc/thermal-zones missing or empty reg/ranges property
arch/arm64/boot/dts/freescale/fsl-ls1046a-rdb-sdk.dtb: Warning (simple_bus_reg): Node /soc/fman@1a00000/cc missing or empty reg/ranges property
```

重新编译全部完成

```
Time of Build Done: Mon Oct 16 01:13:32 PDT 2023 
 arm64 Autobuild Time: 42 Mins 38 Secs !
```

测试结果：已经去除nand flash相关内容，继续烧录内核，仍然无法挂载到根文件系统，不过内核是已经启动了的

```
[    3.484949] VFS: Cannot open root device "PARTUUID=82eb0fdb-04" or unknown-block(179,4): error -30
[    3.493922] Please append a correct "root=" boot option; here are the available partitions:
```

> 来自正点原子驱动开发手册的说明：
>
> Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)
>
> 也就是提示内核崩溃，因为 VFS(虚拟文件系统)不能挂载根文件系统，因为根文件系统目
>
> 录不存在。即使根文件系统目录存在，如果根文件系统目录里面是空的依旧会提示内核崩溃。
>
> 这个就是根文件系统缺失导致的内核崩溃，但是内核是启动了的，只是根文件系统不存在而已。

[VFS: Cannot open root device 解决思路-CSDN博客](https://blog.csdn.net/u011011827/article/details/111227545)

```
VFS: Cannot open root device \"%s\"(A) or %s(B): error %d(C)\n"
Please append a correct \"root=\" boot option; here are the available partitions:\n
VFS: Unable to mount root fs on %s(D)
```

以上是 init/do_mounts.c 文件中的 函数mount_block_root 做的打印，表示 利用所有的文件系统 调用 do_mount_root  对 一个分区(通过是指定的) 进行了挂载,但是还是挂载失败
上面的信息就是打印出来的帮助定位错误的信息

内核会针对不同的情况对 A B C D 进行填充
A : 如果指定的是 root=/dev/hda2 ,那么 A 为 "/dev/" 后面的 hda2
	如果指定的是 root=/xxx/hda2(前五个字节不为"/dev/") ,那么 A 为 /xxx/hda2
B : 根据指定的 root=/dev/hda2 , 根据ROOT_DEV = name_to_dev_t(root_device_name); 算出来的设备号,从而算出来的主次设备号,格式 为 unknown-block(主设备号,次设备号)
C : do_mount_root 的返回值,返回值的定义在 内核代码中的 `include/uapi/asm-generic/errno-base.h`
D : 和B一样

进行分析：

A为 PARTUUID=82eb0fdb-04

B为 unknown-block(179,4)

C为 30  

A的格式是对的,mmc设备的分区名请参考 Documentation/block/cmdline-partition.txt 

B表示已经找到了mmc设备的驱动, 因为主次设备已经出来了,且是对的. 请参考 Documentation/devices.txt

C表示该文件系统为只读 #define EROFS    30  /* Read-only file system */

————————————————

中断进入uboot查看sd卡的第四分区是否存在内容，指令为

```
mmc dev 0
part list mmc 0:4
part mmc mmc 0:4
```

修改启动信息：

```
setenv bootargs console=ttyS0,115200 root=PARTUUID=549892fe-04 earlycon=uart8250,mmio,0x21c0500 mtdparts=1550000.spi:1m(rcw),15m(u-boot),48m(kernel.itb);7e800000.flash:16m(nand_uboot),48m(nand_kernel),448m(nand_free)
```

提示sd卡当前处于保护模式，无法直接修改环境变量

### 2023/10/17

检测sd卡第四分区

```
root@ubuntu:/media/forlinx# fsck -f /dev/sdb4
fsck from util-linux 2.31.1
e2fsck 1.44.1 (24-Mar-2018)
Pass 1: Checking inodes, blocks, and sizes
Pass 2: Checking directory structure
Pass 3: Checking directory connectivity
Pass 4: Checking reference counts
Pass 5: Checking group summary information
system: 53671/1479856 files (0.1% non-contiguous), 809295/5915904 blocks
```

文件系统看起来是干净的，没有出现任何严重的错误。这表明文件系统的完整性没有问题。

检查根文件系统是否只读

```
root@ubuntu:/home/forlinx/nxp/flexbuild_lsdk1906# mount | grep "/dev/sdb4"
/dev/sdb4 on /media/forlinx/system type ext4 (rw,nosuid,nodev,relatime,data=ordered,uhelper=udisks2)
```

其中调试时遇到，无法将环境变量写入到sd卡，检查是否是同一问题

```
=> saveenv 
Saving Environment to MMC... Writing to MMC(0)... 
The SD card is locked. Can not write to a locked card.
```

启动参数

```
Kernel command line: console=ttyS0,115200 earlycon=uart8250,mmio,0x21c0500 root=PARTUUID=05adcb73-04 rw rootwait
```

尝试去掉sd卡写保护，没有思路

检查发现可能缺少ext4系统的模块支持，在defconfig文件中增加`CONFIG_EXT4_FS=y`，重新编译

测试失败，后续查看驱动发现已经有ext4系统的模块支持，并未缺少

尝试在windows上清除磁盘属性

```
在计算机上: DESKTOP-5KTBV78
DISKPART> list disk
  磁盘 ###  状态           大小     可用     Dyn  Gpt
  --------  -------------  -------  -------  ---  ---
  磁盘 0    联机              316 GB  1024 KB        *
  磁盘 1    联机              931 GB  1024 KB
  磁盘 2    联机               29 GB      0 B
DISKPART> select disk 2
磁盘 2 现在是所选磁盘。
DISKPART> attributes disk clear readonly
已成功清除磁盘属性。
DISKPART>
```

重新烧录系统仍然启动挂载失败

但是demo板上是能够修改环境变量，并且启动信息如下：

```
EXT4-fs (mmcblk0p3): 2 orphan inodes deleted
[    4.170467] EXT4-fs (mmcblk0p3): recovery complete
[    4.223947] EXT4-fs (mmcblk0p3): mounted filesystem with ordered data mode. Opts: (null)
[    4.232060] VFS: Mounted root (ext4 filesystem) on device 179:3.
[    4.242157] devtmpfs: mounted
[    4.245595] Freeing unused kernel memory: 1344K
[    5.139632] systemd[1]: System time before build time, advancing clock.
[    5.217775] systemd[1]: systemd 237 running in system mode. (+PAM +AUDIT +SELINUX +IMA +APPARMOR +SMACK +SYSVINIT +UTMP +LIBCRYPTSETUP +GCRYPT +GNUTLS +ACL +XZ +LZ4 +SECCOMP +BLKID +ELFUTILS +KMOD -IDN2 +IDN -PCRE2 default-hierarchy=hybrid)
[    5.239230] systemd[1]: Detected architecture arm64.
```

自研ls1046a板卡，制作sd卡分区没有问题，主次设备号也没有问题，根据以上的大部分分析和测试，总结一下可能的情况

1. 文件系统制作的有问题
2. 烧录文件系统的过程有问题
3. sd卡在板卡上读取和写入有问题

==最终解决后回顾，问题还是第3点，硬件上`SDHC_WP`引脚是拉高的，修改为拉低即可写入系统==

现在已经可以进入到系统了，使用的是nxp制作的根文件系统

```
NXP LSDK 1906 main
localhost login: root
Password:
Welcome to NXP LSDK 1906 main (GNU/Linux 4.14.122-gb9aab3a65-dirty aarch64)

 * Support:        https://www.nxp.com/lsdk
 * Documentation:  https://lsdk.github.io/document
 * Licensing:      https://lsdk.github.io/eula

The programs included with the NXP LSDK are free software, the exact distribution
terms of some programs are described in the individual files in /usr/share/doc.
NXP LSDK comes with ABSOLUTELY NO WARRANTY, to the extent permitted by applicable law.
By using this LSDK, you indicate that you accept the terms of the Agreement in
the link above and you acknowledge that you have the authority, for yourself
or on behalf of your company, to bind your company to these terms.

root@localhost:~# df -h
Filesystem      Size  Used Avail Use% Mounted on
/dev/root        52G  2.9G   46G   6% /
devtmpfs        1.9G     0  1.9G   0% /dev
tmpfs           1.9G     0  1.9G   0% /dev/shm
tmpfs           1.9G  420K  1.9G   1% /run
tmpfs           5.0M     0  5.0M   0% /run/lock
tmpfs           1.9G     0  1.9G   0% /sys/fs/cgroup
/dev/mmcblk0p2  976M   92M  817M  11% /boot
tmpfs           383M     0  383M   0% /run/user/0
```

#### 汇总需要适配及测试的外设

1. 有线网口
2. qspi nor flash
3. 无线wifi模块
4. 固态硬盘
5. 板载emmc
6. nand flash（优先级低，因为ls1046无法从nand启动，作为存储又没有固态硬盘容量大）
7. usb type-c

并且以上有些外设使能还分为uboot阶段和系统内核驱动阶段

| 外设           | uboot使用场景                                    | 系统阶段使用场景                                   |
| -------------- | ------------------------------------------------ | -------------------------------------------------- |
| 有线网口       | tftp下载镜像，固化系统                           | 与AM3354通信、网络通信                             |
| qspi nor flash | 系统启动                                         | ramdisk系统                                        |
| 无线wifi模块   | 暂无，这个阶段可以先做识别                       | 网络通信                                           |
| 固态硬盘       | 暂无，不过需要这个阶段就识别来启动ubuntu1804系统 | ubuntu1804系统                                     |
| 板载emmc       | 系统启动                                         | ubuntu1804系统                                     |
| nand flash     | 暂无，1046A无法使用nand启动                      | 可以启动挂载ubuntu1804系统，不过容量比不上固态硬盘 |
| usb type-c     | 暂无                                             | 与AM3354通信、雷达通信、stm32底板通信、U盘等       |

### 2023/10/18-2023/11/17

清除所有以前生成的映像，除了rootfs，命令如下：

```
flex-builder clean
```

然后开始全盘分析相关宏以及初始化函数，回顾设备树相关知识

github上可以下载官方的手册：**`Devicetree Specifification Release v0.3`**，手册基本就很全面了

[Releases · devicetree-org/devicetree-specification (github.com)](https://github.com/devicetree-org/devicetree-specification/releases)

uboot增加命令补全、打印内存信息等指令，ls1046afrwy_tfa_defconfig文件

```
CONFIG_CMDLINE_EDITING=y
CONFIG_AUTO_COMPLETE=y
CONFIG_CMD_MEMINFO=y
```

这里需要注意的一个点是：之前修改的dts文件是内核的，当时是为了解决nand flash引起的内核启动失败的问题，现在要使能uboot阶段的外设，要修改uboot源码中的dts。

- uboot中的设备树dts文件会被编译为dtb文件，比如u-boot.dtb，然后将u-boot.dtb和uboot镜像合成包含dtb的uboot.bin

  ```
  cmd_u-boot-dtb.bin := cat u-boot-nodtb.bin dts/dt.dtb > u-boot-dtb.bin
  cmd_u-boot.bin := cp u-boot-dtb.bin u-boot.bin
  ```

- linux内核使用的设备树dts文件会被编译为dtb文件，然后直接使用，不会跟uboot中的一样合成镜像，而是由uboot启动内核后，将内核参数和dtb一起传递给内核，内核再去解析dtb文件，由dtb转换成`device_node`，再由`device_node`转换成`platform_device`，`platform_device`和`platform_driver`匹配，匹配成功后会执行驱动中的`probe`函数

DEBUG开启使用宏，需要的时候打开，不需要的时候关闭，否则DEBUG日志信息太多

/home/forlinx/nxp/flexbuild_lsdk1906/packages/firmware/u-boot/include/log.h

```diff
+#define DEBUG
#ifdef DEBUG
#define _DEBUG	1
#else
#define _DEBUG	0
#endif
```



#### uboot之有线网口（未解决）

-  *Realtek OUI is 0x000732.* 由寄存器2和3存放PHY芯片的型号代码，寄存器2(PHY ID1)为高位，而寄存器3(PHY ID2)为低位，根据数据手册，高位OUI_MSB为0000000000011100，低位OUI_LSB为110010，组合成11100110010 = 0x732
- 根据rtl8211fs的数据手册复位后的时延为100ms，为了保障，可以设置为200ms

部分函数调用流程

1. initr_net函数

- initr_net
  - eth_initialize
    - eth_common_init
    
      - miiphy_init
        - INIT_LIST_HEAD
    
      - phy_init
        - phy_realtek_init
          - phy_register
            - drv->probe += gd->reloc_off;
    
    - board_eth_init/cpu_eth_init
    
    - eth_write_hwaddr

2.board_eth_init函数

- board_eth_init 
  - fm_memac_mdio_init
  - fm_info_set_phy_address
  - miiphy_get_dev_by_name
  - fm_info_set_mdio
  - cpu_eth_init
  - pci_eth_init

3.cpu_eth_init函数

- cpu_eth_init
  - fm_standard_init
    - fm_init_common
      - fman_upload_firmware
    - fm_eth_initialize
      - fm_eth_init_mac
      - fm_eth_startup
      - init_phy
        - phy_connect
          - phy_find_by_mask/phy_connect_dev
        - phy_config
      - eth_register

[UBOOT PHY 驱动分析及调试方法](https://www.cnblogs.com/zackary/p/14047944.html)

重要结构体

phy_device

```
struct phy_device {
	/* Information about the PHY type */
	/* And management functions */
	struct mii_dev *bus;
	struct phy_driver *drv;
	void *priv;

#ifdef CONFIG_DM_ETH
	struct udevice *dev;
	ofnode node;
#else
	struct eth_device *dev;
#endif

	/* forced speed & duplex (no autoneg)
	 * partner speed & duplex & pause (autoneg)
	 */
	int speed;
	int duplex;

	/* The most recently read link state */
	int link;
	int port;
	phy_interface_t interface;

	u32 advertising;
	u32 supported;
	u32 mmds;

	int autoneg;
	int addr;
	int pause;
	int asym_pause;
	u32 phy_id;
	bool is_c45;
	u32 flags;
};
```

eth_device

```
struct eth_device {
#define ETH_NAME_LEN 20
	char name[ETH_NAME_LEN];
	unsigned char enetaddr[ARP_HLEN];
	phys_addr_t iobase;
	int state;

	int (*init)(struct eth_device *, bd_t *);
	int (*send)(struct eth_device *, void *packet, int length);
	int (*recv)(struct eth_device *);
	void (*halt)(struct eth_device *);
	int (*mcast)(struct eth_device *, const u8 *enetaddr, int join);
	int (*write_hwaddr)(struct eth_device *);
	struct eth_device *next;
	int index;
	void *priv;
};
```

芯片参考手册第527页，有相关地址说明

**14.5.3 Frame Manager (FMan) Implementation**

```
Block base addresses are as follows:
• FM1 mEMAC1: 1AE_0000h
• FM1 mEMAC2: 1AE_2000h
• FM1 mEMAC3: 1AE_4000h
• FM1 mEMAC4: 1AE_6000h
• FM1 mEMAC5: 1AE_8000h
• FM1 mEMAC6: 1AE_A000h
• FM1 mEMAC9: 1AF_0000h
• FM1 mEMAC10: 1AF_2000h
```

按ardb的版本来看，dts中跟fman相关的内容应该没有配置错误，然后跟正点原子的手册中所说，应该还要看下是不是复位的引脚的问题

参考飞凌设置网口mac

u-boot/net/eth-uclass.c和u-boot/net/eth_legacy.c文件中，在

```
#ifdef CONFIG_NET_RANDOM_ETHADDR
		net_random_ethaddr(dev->enetaddr);
		printf("\nWarning: %s (eth%d) using random MAC address - %pM\n",
		       dev->name, eth_number, dev->enetaddr);
```

下面增加如下内容，为设置网口的mac值，此处是第一次时会随机生成值，然后将该值保存到环境变量，第二次启动后就不会重新生成随机值了，而是使用环境变量里的值：

```
char tmp[50] = {'\n'};
if (dev->seq == 0){
    sprintf(tmp, "setenv ethaddr %pM\n", pdata->enetaddr);
}
else{
    sprintf(tmp, "setenv eth%daddr %pM\n", dev->seq, pdata->enetaddr);
}
run_command(tmp, 0);
run_command("saveenv", 0);
```

初始化错误的相关信息

```
PHY reset timed out
FM1@DTSEC3, FM1@DTSEC4, FM1@DTSEC5, FM1@DTSEC6 [PRIME], FM1@DTSEC9, FM1@DTSEC10
```

并且当前出现的问题是设备设置对应不上，本身设置的是DTSEC2、3、4、5、6，但是使用的确是3、4、5、6、9、10，这些设备的设置在`eth_initialize`函数及内部调用的`eth_common_init`函数中开始，使用变量名为`eth_devices`，声明定义如下：

```
static struct eth_device *eth_devices;
```

Eth.c中有个eth_devices需要外部调用函数eth_register做初始化工作，其它函数(除eth_initialize外)都必须在这个初始化之后才能使用。

结构eth_devices是个循环链表，可包含多个eth_device。eth_register每次调用添加一个结构，调用多次可生成循环链表。eth_devices指向链表的第1个元素。

先定位为什么会出现DTSEC9和DTSEC10（预留）

> 后面返回填坑：因为设置的serdes1是3333，对应的MAC为SGMII9、10、5、6，这个值是不能随意设置的，所以之前使用的2、5、6是错误的，然后当前未使用的为1、2

从源码分析来看，eth_common_init没有涉及到eth_devices，先做个测试，看下eth_common_init函数调用完成后eth_devices的值是否为空

在eth_initialize函数中`eth_common_init();`这一行后增加如下代码

```
if (!eth_devices) {
    puts("eth_common_init No ethernet found.\n");
    bootstage_error(BOOTSTAGE_ID_NET_ETH_START);
}
```

重新烧录，测试结果如下

```
eth_common_init No ethernet found.
```

说明在eth_common_init调用完成的阶段，eth_devices仍然是为空的，eth_common_init不涉及eth_devices，删除测试代码

说明只有board_eth_init函数和cpu_eth_init函数中涉及eth_devices，进一步测试如下：

```
board_eth_init  ethernet found.
```

分析board_eth_init，注意board_eth_init最后也会调用cpu_eth_init

memac_mdio_info 结构体分析

| struct memac_mdio_info {            | dtsec_mdio_info                                              | tgec_mdio_info                                               |
| ----------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| struct memac_mdio_controller *regs; | dtsec_mdio_info.regs =    (struct memac_mdio_controller *)CONFIG_SYS_FM1_DTSEC_MDIO_ADDR; | tgec_mdio_info.regs = (struct memac_mdio_controller *)CONFIG_SYS_FM1_TGEC_MDIO_ADDR; |
| char *name;                         | dtsec_mdio_info.name = DEFAULT_FM_MDIO_NAME;                 | tgec_mdio_info.name = DEFAULT_FM_TGEC_MDIO_NAME;             |
| };                                  |                                                              |                                                              |

其中dtsec_mdio_info和tgec_mdio_info实例对应的值

| dtsec_mdio_info                                              | tgec_mdio_info                                               |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| \#define CONFIG_SYS_FM1_DTSEC_MDIO_ADDR  (CONFIG_SYS_FSL_FM1_ADDR + 0xfd000) | #define CONFIG_SYS_FM1_TGEC_MDIO_ADDR	(CONFIG_SYS_FSL_FM1_ADDR + 0xf1000) |
| #define DEFAULT_FM_MDIO_NAME "FSL_MDIO0"                     | #define DEFAULT_FM_TGEC_MDIO_NAME "FM_TGEC_MDIO"             |
| #define CONFIG_SYS_FSL_FM1_ADDR	(CONFIG_SYS_IMMR + CONFIG_SYS_FSL_FM1_OFFSET) |                                                              |
| CONFIG_SYS_IMMR = 0x01000000                                 |                                                              |
| CONFIG_SYS_FSL_FM1_OFFSET = 0xa00000                         |                                                              |
| 1A0_0000 - 1AF_FFFF Frame manager (FMan)                     |                                                              |

在分析fm_info_set_phy_address的时候，查看别的ls1043aqds的eth.c代码时，发现之前有个点没有注意到，就是

FM1_DTSEC后的值，是指的是Fman的MAC值，需要设置与serdes对应，是不能随便设置的，之前这里的值是参照了ls1046ardb，因为自研板卡的网口是参照ls1046ardb，但是忽略了应该与与serdes对应，设置正确后仍然没有解决问题。

需要返回解决`PHY reset timed out`的问题，reg是在phy_read函数中设置，该函数轮询控制寄存器使复位位变为0，测试reg输出值为63355，所以该轮询控制寄存器一直到循环的0.5秒结束了，都没有能设置为0，便会输出`PHY reset timed out`

测试输出

```
phy_read reg:0
phy_read reg:0
phy_read reg:65535
PHY reset timed out
reg:65535
phy_read reg:65535
PHY reset timed out
reg:65535
phy_read reg:65535
PHY reset timed out
reg:65535
```

由上所示，第一和第二次（RGMII）的时候设置成功phy_read reg:0，第三次及以后（SRGMII）的时候失败phy_read reg:65535，导致后续的PHY reset timed out。

测试输出mac对应的phy地址，自研ls1046正常对应关系是9<->3，5<->4，6<->5，下标输出应该是845<->345

```
fm_info[6].phy_addr:3
fm_info[4].phy_addr:4
fm_info[5].phy_addr:5
```

但是测试结果确是645<->345，

分析源码fm_info_set_phy_address函数，fm_info[]的类型是fm_eth_info

```
struct fm_eth_info fm_info[]
```

确定部分宏的值，如下：

CONFIG_SYS_NUM_FM1_DTSEC = 8;

\#define MII_BMCR     0x00

fm_eth_info结构体如下：

| struct fm_eth_info {     | FM1_DTSEC9                                                   |                                                              |
| ------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| u8 enabled;              |                                                              |                                                              |
| u8 fm;                   | idx                                                          | 1                                                            |
| u8 num;                  | n - 1                                                        | n=9                                                          |
| u8 phy_addr;             | SGMII_PHY1_ADDR                                              | 3                                                            |
| int index;               | idx                                                          | 1                                                            |
| u16 rx_port_id;          | RX_PORT_1G_BASE + n - 1                                      | RX_PORT_1G_BASE + 8                                          |
| u16 tx_port_id;          | TX_PORT_1G_BASE + n - 1                                      | TX_PORT_1G_BASE + 8                                          |
| enum fm_port port;       | FM##idx##_DTSEC##n                                           | FM1_DTSEC9                                                   |
| enum fm_eth_type type;   | FM_ETH_1G_E                                                  |                                                              |
| void *phy_regs;          | (void *)pregs                                                | CONFIG_SYS_FM1_DTSEC_MDIO_ADDR = <br />(CONFIG_SYS_FSL_FM1_ADDR + 0xfd000) |
| phy_interface_t enet_if; | PHY_INTERFACE_MODE_NONE                                      | 为空，注意默认初始化都是<br />这个模式，再分析哪个阶段设置<br />为其他模式，在include/phy_interface.h下定义，<br />这里是比如sgmii、qsgmii的选择 |
| u32 compat_offset;       | CONFIG_SYS_FSL_FM##idx##_OFFSET +  offsetof(struct ccsr_fman, memac[n-1]) |                                                              |
| struct mii_dev *bus;     | bus                                                          | dev                                                          |
| };                       |                                                              |                                                              |

mii_dev 结构体如下：

| struct mii_dev {                                             |                                                          |      |
| ------------------------------------------------------------ | -------------------------------------------------------- | ---- |
| struct list_head link;                                       |                                                          |      |
| char name[MDIO_NAME_LEN];                                    |                                                          |      |
| void *priv;                                                  |                                                          |      |
| int (*read)(struct mii_dev *bus, int addr, int devad, int reg); | 这个是函数指针，等待别的地方给这个read传递真实的调用函数 |      |
| int (*write)(struct mii_dev *bus, int addr, int devad, int reg, |                                                          |      |
| u16 val);                                                    |                                                          |      |
| int (*reset)(struct mii_dev *bus);                           |                                                          |      |
| struct phy_device *phymap[PHY_MAX_ADDR];                     |                                                          |      |
| u32 phy_mask;                                                |                                                          |      |
| };                                                           |                                                          |      |

测试输出

```
fm_info_get_phy_address(1):0,
fm_info_get_phy_address(2):1,
fm_info_get_phy_address(3):2,
fm_info_get_phy_address(4):4,
fm_info_get_phy_address(5):5,
fm_info_get_phy_address(6):3,
fm_info_get_phy_address(7):0,
```

说明FM1_DTSEC9确实没有设置成功，并且导致了FM1_DTSEC7被设置为了FM1_DTSEC9需要对应的PHY地址值3

demo板，使用mii命令，正常的网口信息识别输出

```
=> mii info
PHY 0x1C: OUI = 0x01C1, Model = 0x27, Rev = 0x00,  10baseT, HDX
PHY 0x1D: OUI = 0x01C1, Model = 0x27, Rev = 0x00,  10baseT, HDX
PHY 0x1E: OUI = 0x01C1, Model = 0x27, Rev = 0x00,  10baseT, HDX
PHY 0x1F: OUI = 0x01C1, Model = 0x27, Rev = 0x00,  10baseT, HDX
```

自研ls1046板，输出信息如下，没有一个地址设置成功，包括与serdes无关的RGMII：

```
=> mii info
PHY 0x00: OUI = 0x0000, Model = 0x00, Rev = 0x00,  10baseT, HDX
PHY 0x01: OUI = 0x0000, Model = 0x00, Rev = 0x00,  10baseT, HDX
PHY 0x02: OUI = 0x0000, Model = 0x00, Rev = 0x00,  10baseT, HDX
PHY 0x03: OUI = 0x0000, Model = 0x00, Rev = 0x00,  10baseT, HDX
PHY 0x04: OUI = 0x0000, Model = 0x00, Rev = 0x00,  10baseT, HDX
PHY 0x05: OUI = 0x0000, Model = 0x00, Rev = 0x00,  10baseT, HDX
```

说明之前即使复位成功的RGMII3、4同样没有识别成功，SGMII的错误并没有影响到RGMII，

测试FM1_DTSEC3和FM1_DTSEC4的模式是否是RGMII，FM1_DTSEC5、6、9是否是SGMII，结果如下：

```
FM1_DTSEC3 enet_if PHY_INTERFACE_MODE_RGMII_TXID
FM1_DTSEC4 enet_if PHY_INTERFACE_MODE_RGMII_TXID
FM1_DTSEC256910 enet_if PHY_INTERFACE_MODE_SGMII
FM1_DTSEC256910 enet_if PHY_INTERFACE_MODE_SGMII
FM1_DTSEC256910 enet_if PHY_INTERFACE_MODE_SGMII
FM1_DTSEC256910 enet_if PHY_INTERFACE_MODE_SGMII
Net:   phy_realtek_init
```

ls1046参考手册中231页，复位控制字中416-418、419-421 分别为EC1、EC2，是用于配置RGMII1和RGMII2等其他功能的，要设置为RGMII，则将EC1、EC2修改为0。因为不使用xfi万兆网口，所以全部使用100MHz，设置SRDS_PLL_REF_CLK_SEL_S1=0

修改完毕后测试，网口还是没有使用成功，这部分修改应该是需要的，估计还是因为复位引脚初始化没有成功的问题。

linux下能识别设备了，详情查看下方*linux驱动之有线网口*

uboot中测试还没解决该问题，因为是在fman0节点下设置的，uboot的fman驱动代码和内核的fman驱动代码并不完全一致，缺少部分驱动代码，不过本质上解决方式都是一样的，就是把==GPIO1_25拉低==

由于uboot上的没有完整的fman驱动，无法匹配，所以尝试直接在代码中设置：

方式1：直接使用设置GPIO的函数

gpio_request 函数
gpio_request 函数用于申请一个 GPIO 管脚，在使用一个 GPIO 之前一定要使用 gpio_request进行申请，函数原型如下：

```c
int gpio_request(unsigned gpio, const char *label)
```

gpio_direction_output 函数

此函数用于设置某个 GPIO 为输出，并且设置默认输出值，函数原型如下，某些源码中内部主要函数为gpio_set_value ，还有些使用writel(val, GPIO_BASE + off);，这些函数的函数签名一样，不过内部实现不一样，使用时理清调用的哪个源文件实现的函数（TODO：2023/11/06 uboot去调用的时候，无法链接到正确的函数实现位置，但是GPIO命令实现源码中确可以正确链接）：

```c
int gpio_direction_output(unsigned gpio, int value)
```

gpio_set_value 函数

此函数用于设置某个 GPIO 的值，此函数是个宏，定义如下

```c
#define gpio_set_value __gpio_set_value
void __gpio_set_value(unsigned gpio, int value)
```

方式2：底层使用setbits_be32函数

方式3：先使用uboot提供的`gpio`命令（底层使用的也是gpio_direction_output 等函数），进行引脚清零/拉高配置，确认操作可行后，再在初始化代码中增加使用设置GPIO的代码

步骤如下：

- **在uboot下的defconfig 打开如下配置**

  ```
  CONFIG_DM=y
  CONFIG_DM_GPIO=y
  CONFIG_CMD_GPIO=y
  ```

- **重新编译u-boot后会生成cmd：gpio**
  - （板子上电时连续按回车键）进入到板端uboot cmdline下执行" gpio status -a " 查看板端对应的gpio numbe

- **利用 uboot gpio 命令操作GPIO 做测试**
  
  - gpio c 0 ; 将第0根PIN清零（拉低）
  - gpio s 0 ; 将第0根PIN设为output同时拉高

方式4（？）：设备树方式：虽然uboot中无法fman驱动节点中设置复位引脚拉低，但是可以尝试直接使用pinctrl子系统拉低试试，直接设置引脚拉低，不配置为复位引脚

以下四种方式测试说明：方式一gpio_direction_output函数在链接成uboot二进制文件的时候一直报错，无法链接到gpio-uclass.c中的函数实现；方式二setbits_be32函数底层使用的是out_be32，但是这两个函数即使设置了，也一直PHY reset timed out，跟之前相比没有起到作用；方式三配置了uboot gpio 命令后，执行" gpio status -a " 没有任何输出





setenv serverip 192.168.0.100

setenv ipaddr 192.168.0.232

setenv netmask 255.255.255.0

setenv gatewayip 192.168.0.1

| struct ccsr_gpio { |      |
| ------------------ | ---- |
| u32 gpdir;         |      |
| u32 gpodr;         |      |
| u32 gpdat;         |      |
| u32 gpier;         |      |
| u32 gpimr;         |      |
| u32 gpicr;         |      |
| u32 gpibe;         |      |
| };                 |      |



#### linux驱动之有线网口

内核启动过程中的打印信息

```
Freescale FM module, FMD API version 21.1.0
[    2.639055] Freescale FM Ports module
[    2.642723] fsl_mac: fsl_mac: FSL FMan MAC API based driver
[    2.648446] fsl_mac 1ae4000.ethernet: of_get_mac_address(/soc/fman@1a00000/ethernet@e4000) failed
[    2.657331] fsl_mac: probe of 1ae4000.ethernet failed with error -22
[    2.663720] fsl_mac 1ae6000.ethernet: of_get_mac_address(/soc/fman@1a00000/ethernet@e6000) failed
[    2.672603] fsl_mac: probe of 1ae6000.ethernet failed with error -22
[    2.678990] fsl_mac 1ae8000.ethernet: of_get_mac_address(/soc/fman@1a00000/ethernet@e8000) failed
[    2.687871] fsl_mac: probe of 1ae8000.ethernet failed with error -22
[    2.694258] fsl_mac 1aea000.ethernet: of_get_mac_address(/soc/fman@1a00000/ethernet@ea000) failed
[    2.703141] fsl_mac: probe of 1aea000.ethernet failed with error -22
[    2.709528] fsl_mac 1af0000.ethernet: of_get_mac_address(/soc/fman@1a00000/ethernet@f0000) failed
[    2.718410] fsl_mac: probe of 1af0000.ethernet failed with error -22
[    2.724798] fsl_mac 1af2000.ethernet: of_get_mac_address(/soc/fman@1a00000/ethernet@f2000) failed
[    2.733678] fsl_mac: probe of 1af2000.ethernet failed with error -22
```

1. `Freescale FM module, FMD API version 21.1.0`: 这是启动消息的标题，表明系统中加载了Freescale FM模块，版本为21.1.0。
2. `Freescale FM Ports module`: 这是关于Freescale FM模块端口的消息，表示模块已经加载。
3. `fsl_mac: fsl_mac: FSL FMan MAC API based driver`: 这是有关Freescale FM MAC（Media Access Control）驱动程序的消息，它基于Freescale FMan MAC API。
4. 接下来的一系列消息（例如 `fsl_mac 1ae4000.ethernet`, `of_get_mac_address(/soc/fman@1a00000/ethernet@e4000) failed`）指示了在初始化Freescale FM MAC时遇到了问题。这些消息尝试获取Freescale FM MAC的地址，但失败了，错误代码为-22。这通常表示硬件配置问题或设备树（Device Tree）中的配置问题。

在设备树源码中，注意虽然设置了别名`enet0: ethernet@e0000`，但是在提供的设备树源码中还是使用了ethernet@e0000，所有在使用时应该用ethernet@`e0000`，否则@后的地址值对应不上

修改后重新编译测试

[以太网驱动的流程浅析(五)-mii_bus初始化以及phy id的获取【原创】 - Sky&Zhang - 博客园 (cnblogs.com)](https://www.cnblogs.com/sky-heaven/p/11942921.html)

##### linux下识别的解决方式

> 根据原理图，demoA原本使用的复位引脚是GPIO3_27，但是在自研的开发板中GPIO3_27被其他使用了，由硬件组重新搭建电路，并根据预留的GPIO资源选择GPIO1_25，因此接下来需要使能GPIO1_25并配置拉低该引脚。

1. 根据ls1046参考手册第186页设置使能GPIO1[25]，其他为0，IRQ[5]为1，即是001000000

[【精选】1046A-C2 GPIO的复用_ls1046 中断 irq0-CSDN博客](https://blog.csdn.net/qq_40177571/article/details/119215816)

2. 在fsl-ls1046a-frwy.dts（注意这里是linux源码中的设备树文件）中&fman0 下方增加如下代码，注意虽然\#define GPIO_ACTIVE_LOW 1，这里要直接写1，写GPIO_ACTIVE_LOW 会报错语法错误

```
&fman0 {
	status = "okay";
	phy-reset-gpios = <&gpio0 25 1>;
	phy-reset-duration = <100>;
    phy-reset-post-delay = <100>;
    
    ...
}
```

进行测试，成功识别到网口设备了，除了mac-9这个设备，其他四个都识别成功

ubuntu系统中测试如下：

```
root@localhost:/etc/systemd/network# ifconfig
docker0: flags=4099<UP,BROADCAST,MULTICAST>  mtu 1500
        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255
        ether 02:42:00:68:69:10  txqueuelen 0  (Ethernet)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

fm1-mac3: flags=4099<UP,BROADCAST,MULTICAST>  mtu 1500
        inet 192.168.0.232  netmask 255.255.255.0  broadcast 192.168.0.255
        ether 4e:49:fb:ec:4a:b2  txqueuelen 1000  (Ethernet)
        RX packets 16  bytes 1249 (1.2 KB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
        device memory 0x1ae4000-1ae4fff
```

进行ip配置，若想将网口设置为静态IP，这里以设置fm1-mac3网口静态IP为 192.168.0.232 为
例，创建fm1-mac3网口的配置文件，请参考以下设置（没有fm1-mac3.network文件，则直接新建该文件即可）:

```
root@localhost:~# vi /etc/systemd/network/fm1-mac3.network
[Match]
Name=fm1-mac3
KernelCommandLine=!root=/dev/nfs
[Network]
#DHCP=yes
Address=192.168.0.232/24
Gateway=192.168.0.1
```

接上网线测试，ping不通，可能跟防火墙还有其他有关

```
root@localhost:~# systemctl status fmc.service
● fmc.service - NXP Frame Manager Configuration tool
   Loaded: loaded (/lib/systemd/system/fmc.service; enabled; vendor preset: enabled)
   Active: failed (Result: exit-code) since Thu 2023-03-02 12:58:07 UTC; 24s ago
  Process: 3894 ExecStart=/usr/local/fmc/init-ls104xa (code=exited, status=1/FAILURE)
 Main PID: 3894 (code=exited, status=1/FAILURE)

Mar 02 12:58:05 localhost systemd[1]: Starting NXP Frame Manager Configuration tool...
Mar 02 12:58:05 localhost init-ls104xa[3894]: Configuring for LS1046A FRWY...
Mar 02 12:58:06 localhost init-ls104xa[3894]: ERR : Invocation of FM_PORT_Open for fm0/port/MAC/1 failed
Mar 02 12:58:07 localhost systemd[1]: fmc.service: Main process exited, code=exited, status=1/FAILURE
Mar 02 12:58:07 localhost systemd[1]: fmc.service: Failed with result 'exit-code'.
Mar 02 12:58:07 localhost systemd[1]: Failed to start NXP Frame Manager Configuration tool.
```

检查网卡状态

```
ethtool eth0
```

上述命令可以查看网卡的状态，确认是否正常连通。如果显示“Link detected: no”则表明网卡物理连接出现了问题，需要确认硬件状态。

```
root@localhost:/sys/class/net/fm1-mac3# ethtool fm1-mac5
Settings for fm1-mac5:
        Supported ports: [ MII ]
        Supported link modes:   Not reported
        Supported pause frame use: Symmetric Receive-only
        Supports auto-negotiation: No
        Supported FEC modes: Not reported
        Advertised link modes:  Not reported
        Advertised pause frame use: Symmetric Receive-only
        Advertised auto-negotiation: No
        Advertised FEC modes: Not reported
        Speed: 10Mb/s
        Duplex: Half
        Port: MII
        PHYAD: 4
        Transceiver: internal
        Auto-negotiation: on
        Supports Wake-on: d
        Wake-on: d
        Current message level: 0xffffffff (-1)
                               drv probe link timer ifdown ifup rx_err tx_err tx_queued intr tx_done rx_status pktdata hw wol 0xffff8000
        Link detected: no
```

查看Linux下网卡状态或 是否连接

```
Mar 02 12:58:50 localhost kernel: IPv6: ADDRCONF(NETDEV_UP): fm1-mac3: link is not ready
Mar 02 12:59:44 localhost kernel: IPv6: ADDRCONF(NETDEV_UP): fm1-mac3: link is not ready
Mar 02 12:59:53 localhost systemd[1]: Stopping ifup for fm1-mac3...
```

虽然ifconfig显示状态已经up

```
root@localhost:~# ifconfig 
lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        inet6 ::1  prefixlen 128  scopeid 0x10<host>
        loop  txqueuelen 1000  (Local Loopback)
        RX packets 80  bytes 5920 (5.9 KB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 80  bytes 5920 (5.9 KB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
```

根据以下信息，state DOWN，fm1-mac3其实仍然没有up

```
root@localhost:~# ip addr show fm1-mac3
2: fm1-mac3: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc mq state DOWN group default qlen 1000
```

ip addr命令
工作正常情况下：UP,LOWER_UP + state UP
被拔网线的情况：NO-CARRIER,UP + state DOWN
link set down:空 + state DOWN

ifconfig命令
工作正常情况下：UP+RUNNING
VM虚拟机模拟拔网线，网络设备状态 UP+无RUNNING
ip link set dev eth1 down之后，网络设备状态 无UP+无RUNNING

2: eth0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc pfifo_fast state DOWN group default qlen 1000 实际是有在工作的，为什么state down？？？？

 NO-CARRIED状态就是表示网卡已经处于up状态，但是因为物理层的原因导致网络没连接，比如网线没插好之类的。

网卡链路物理状态故障检测流程
如果我们发现如下网卡故障：

```
ip addr | grep stat # 可以看到链路的物理状态，可以看到状态down，有没有载波的显示
eth0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc mq state DOWN qlen 1000
```

上面信息显示 eth0 网卡并没有载波，使用ifconfig eth0 也没有RUNNING这样的标志位~

排查步骤：

（1）先查看下服务器上网络接口是否正常，光模块的话看下模块插口是否有红色光点，电口的话看下指示灯是否正常；

（2）检查光纤线接口里是否有红色光点，交换机上各模块或接口是否松动，没有插牢固；

（3）ip link set eth0 up 尝试手动启动；

（4）检查Pcie卡是否有问题，主板是否正常等；





| Internal Interrupt Number | Interrupt Source     |
| :------------------------ | -------------------- |
| 76                        | Frame Manager (FMan) |
| 77                        | FMAN/QMAN/BMAN error |

##### 有线网口调试问题：无法ping通外部设备

使用环境如下：

lsdk：1906

Linux Kernel：4.14

编译主机：ubuntu1804

PHY芯片：RTL8211FS

问题描述：

目前能够正常启用网口识别如下：

```
root@localhost:~# ifconfig
fm1-mac3: flags=4099<UP,BROADCAST,MULTICAST>  mtu 1500
        ether aa:4e:b8:a9:b5:26  txqueuelen 1000  (Ethernet)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
        device memory 0x1ae4000-1ae4fff

fm1-mac5: flags=4099<UP,BROADCAST,MULTICAST>  mtu 1500
        ether 46:ae:e3:a0:97:54  txqueuelen 1000  (Ethernet)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
        device memory 0x1ae8000-1ae8fff

lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        inet6 ::1  prefixlen 128  scopeid 0x10<host>
        loop  txqueuelen 1000  (Local Loopback)
        RX packets 320  bytes 22720 (22.7 KB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 320  bytes 22720 (22.7 KB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
```

ethtool查看信息如下：

```
root@localhost:~# ip link set fm1-mac3 up
root@localhost:~# ip link set fm1-mac5 up
root@localhost:~# ethtool fm1-mac5
Settings for fm1-mac5:
        Supported ports: [ MII ]
        Supported link modes:   Not reported
        Supported pause frame use: Symmetric Receive-only
        Supports auto-negotiation: No
        Supported FEC modes: Not reported
        Advertised link modes:  Not reported
        Advertised pause frame use: Symmetric Receive-only
        Advertised auto-negotiation: No
        Advertised FEC modes: Not reported
        Speed: 10Mb/s
        Duplex: Half
        Port: MII
        PHYAD: 4
        Transceiver: internal
        Auto-negotiation: on
        Supports Wake-on: d
        Wake-on: d
        Current message level: 0xffffffff (-1)
                               drv probe link timer ifdown ifup rx_err tx_err tx_queued intr tx_done rx_status pktdata hw wol 0xffff8000
        Link detected: no
```

网线也是正常接入了

进行ip设置后如下：

```
root@localhost:~# ifconfig fm1-mac5 192.168.0.232
root@localhost:~# ifconfig
fm1-mac3: flags=4099<UP,BROADCAST,MULTICAST>  mtu 1500
        ether aa:4e:b8:a9:b5:26  txqueuelen 1000  (Ethernet)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
        device memory 0x1ae4000-1ae4fff

fm1-mac5: flags=4099<UP,BROADCAST,MULTICAST>  mtu 1500
        inet 192.168.0.232  netmask 255.255.255.0  broadcast 192.168.0.255
        ether 46:ae:e3:a0:97:54  txqueuelen 1000  (Ethernet)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
        device memory 0x1ae8000-1ae8fff
```

但是只能ping通自己，不能ping通其他设备

```
root@localhost:~# ping 192.168.0.232
PING 192.168.0.232 (192.168.0.232) 56(84) bytes of data.
64 bytes from 192.168.0.232: icmp_seq=1 ttl=64 time=0.043 ms
64 bytes from 192.168.0.232: icmp_seq=2 ttl=64 time=0.036 ms
64 bytes from 192.168.0.232: icmp_seq=3 ttl=64 time=0.029 ms
^C
--- 192.168.0.232 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2028ms
rtt min/avg/max/mdev = 0.029/0.036/0.043/0.005 ms
root@localhost:~# ping 192.168.0.100
PING 192.168.0.100 (192.168.0.100) 56(84) bytes of data.
From 192.168.0.232 icmp_seq=1 Destination Host Unreachable
From 192.168.0.232 icmp_seq=2 Destination Host Unreachable
From 192.168.0.232 icmp_seq=3 Destination Host Unreachable
From 192.168.0.232 icmp_seq=4 Destination Host Unreachable
From 192.168.0.232 icmp_seq=5 Destination Host Unreachable
From 192.168.0.232 icmp_seq=6 Destination Host Unreachable
^C
--- 192.168.0.100 ping statistics ---
7 packets transmitted, 0 received, +6 errors, 100% packet loss, time 6145ms
pipe 4
```

[linux 网络诊断 & Troubleshooting_link detected: no-CSDN博客](https://blog.csdn.net/GW569453350game/article/details/53008105)

/home/forlinx/nxp/flexbuild_lsdk1906/packages/linux/linux/Documentation/devicetree/bindings/net/phy.txt

/home/forlinx/nxp/flexbuild_lsdk1906/packages/linux/linux/Documentation/devicetree/bindings/net/mdio.txt

虽然参考文档中使用的方式是这样，并且设备树更改如下：

```
mdio@fc000 {
		reset-gpios = <&gpio0 25 1>;
		reset-delay-us = <200000>;
		rgmii_phy1: ethernet-phy@1 {
			reg = <0x1>;
		};
		......
	};
```

但是在up网口设备时，报错如下

```
root@ubuntu:~# ifconfig fm1-mac5 up
[   62.476454] fsl_dpa soc:fsl,dpaa:ethernet@4 fm1-mac5: Could not connect to PHY /soc/fman@1a00000/mdio@fc000/ethernet-phy@4
[   62.487663] fsl_dpa soc:fsl,dpaa:ethernet@4 fm1-mac5: init_phy() = -19
```

更换回之前的写法

```
&fman0 {
	status = "okay";
	phy-reset-gpios = <&gpio0 25 1>;
	phy-reset-duration = <100>;
    phy-reset-post-delay = <100>;
    
    ......
}
```

重新编译并烧录进行测试，能够正常ifconfig fm1-mac3 up没有报错

##### 复用情况

==GPIO1_25已经被PMIC的IRQ5复用，不能将IRQ5的中断配置取消==

之前的修改GPIO1_25的方式有问题

周一测试网口复位

使用GPIO1_31，多次测试不同设备树语法方式进行复位

[设备树 phy节点 使用说明_phy 设备树-CSDN博客](https://blog.csdn.net/weixin_45647912/article/details/108975862)

以上的链接说明的是phy节点可以单独设置

```
// reset-gpios = <&gpio0 31 1>;
// reset-delay-us = <100000>;
```

但是在lsdk1906的版本貌似还不支持该属性





#### uboot之qspi flash（未解决）

|            | demo                          | 自研                     |
| ---------- | ----------------------------- | ------------------------ |
| qspi flash | MT25QU512ABB8ESF-0SIT（64MB） | MT25QL256ABA8ESF（32MB） |
| _jedec_id  | 0x20bb20                      | 0x20ba19                 |
| Voltage    | U = 1.7–2.0V                  | L = 2.7–3.6V             |

id的定义查看对应芯片手册

根据型号两块flash的区别：容量大小不一样，以及u和l的区别

- Voltage L = 2.7–3.6V U = 1.7–2.0V

[linux挂载QSPI FLASH_qspi flash是nor还是nand-CSDN博客](https://blog.csdn.net/m0_37765662/article/details/110541016)

[嵌入式开发实战系列：QSPI Flash驱动功能解析 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/661683543)

[QSPI Flash存储控制器（概述）_Kyph的博客-CSDN博客](https://blog.csdn.net/lsshao/article/details/119752208)

[FSL-QUADSPI - NXP Community](https://community.nxp.com/t5/Other-NXP-Products/FSL-QUADSPI/m-p/1211099)

[uboot移植nor-flash - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/76221655?from_voters_page=true)

[SPI Flash驱动_linux spiflash-CSDN博客](https://blog.csdn.net/weixin_44023607/article/details/129335834)

[Chip Select goes away soon after the transfer to a SPI slave is complete. Why? - Linux Kernel - RocketBoards Forum](https://forum.rocketboards.org/t/chip-select-goes-away-soon-after-the-transfer-to-a-spi-slave-is-complete-why/1070)

识别测试指令：

```
=> sf probe 0:0 //进行连接flash
```

测试结果，识别失败

```
=> sf probe
unrecognized JEDEC id bytes: ff, ff, ff
Failed to initialize SPI flash at 0:0 (error -2)
```

` unrecognized JEDEC id bytes: ff, ff, ff`，ID信息全为0xff，证明SPI读取过程出错了。

要是id未定义，也应该是unrecognized JEDEC id bytes: 20，ba，19

说明除了芯片型号不同，还有其他的问题









容量设置为32M，如下；

```
/* QSPI device */
#ifndef SPL_NO_QSPI
#ifdef CONFIG_FSL_QSPI
#define CONFIG_SPI_FLASH_SPANSION
#define FSL_QSPI_FLASH_SIZE		SZ_64M
#define FSL_QSPI_FLASH_NUM		2
#endif
#endif
```

其中FSL_QSPI_FLASH_SIZE为SZ_64M，而自研的板卡为32M





#### linux驱动之qspi flash

```
root@localhost:~# dmesg | grep spi
[    2.501820] fsl-quadspi 1550000.quadspi: unrecognized JEDEC id bytes: ff, ff, ff
[    2.509226] fsl-quadspi 1550000.quadspi: Freescale QuadSPI probe failed
[    2.515860] fsl-quadspi: probe of 1550000.quadspi failed with error -2
```



#### uboot之sata固态硬盘（解决）

由于fsl-ls1046a.dtsi中status = "disabled";

```
sata: sata@3200000 {
    compatible = "fsl,ls1046a-ahci";
    /* ccsr sata base */
    /* ecc sata addr*/
    reg = <0x0 0x3200000 0x0 0x10000
           0x0 0x20140520 0x0 0x4>;
    reg-names = "sata-base", "ecc-addr";
    interrupts = <0 69 4>;
    clocks = <&clockgen 4 1>;
    status = "disabled";
};
```

在fsl-ls1046a-frwy.dts中增加以下代码来启用sata

```
&sata {
  status = "okay";
};
```

重新制作镜像烧录进入uboot，使用`scsi scan`命令，成功检测到120G的固态硬盘

```
=> scsi scan
scanning bus for devices...
Target spinup took 0 ms.
AHCI 0001.0301 32 slots 1 ports 6 Gbps 0x1 impl SATA mode
flags: 64bit ncq pm clo only pmp fbss pio slum part ccc apst
  Device 0: (0:0) Vendor: ATA Prod.: Lenovo SSD SL700 Rev: W022
            Type: Hard Disk
            Capacity: 122104.3 MB = 119.2 GB (250069680 x 512)
```

查看当前分区信息

```
=> scsi part 0
Partition Map for SCSI device 0  --   Partition Type: DOS
Part    Start Sector    Num Sectors     UUID            Type
  1     2048            250067632       e31484f6-01     83
```

#### linux驱动之sata固态硬盘（解决）

lsdk1906源码能正常识别该固态硬盘，所以暂不需要别的操作，识别情况如下：

```
[root@TinyLSDK ~]$ df -h
Filesystem                Size      Used Available Use% Mounted on
/dev/root               283.9M     38.0M    226.9M  14% /
devtmpfs                  1.8G      4.0K      1.8G   0% /dev
tmpfs                     1.9G    104.0K      1.9G   0% /run
tmpfs                     1.9G    104.0K      1.9G   0% /var/volatile
/dev/sda1               116.9G     60.0M    110.8G   0% /run/media/sda1
/dev/mmcblk0p3            5.8G     12.0M      5.5G   0% /run/media/mmcblk0p3
/dev/mmcblk0p1           92.9M     72.0K     85.8M   0% /run/media/mmcblk0p1
/dev/mmcblk0p4           22.1G     43.9M     20.9G   0% /run/media/mmcblk0p4
/dev/mmcblk0p2          975.9M      1.3M    907.4M   0% /run/media/mmcblk0p2
```

其中

```
/dev/sda1               116.9G     60.0M    110.8G   0% /run/media/sda1
```

为接入的120G固态硬盘，固态硬盘移植适配完成。

### 2023/11/20-24

#### linux驱动之USB

USB 3.0模块有以下工作模式:

- 主机模式:SS/HS/FS/LS
- 设备模式:SS/HS/FS
- otg: hs / fs / ls

以下是demoA板卡上的USB3.0 type-A接口，接入拓展坞（USB type-A、网口）、USB3.0 U盘后，使用lsusb指令查看信息，可以看到能够正常识别拓展坞和U盘的接入

```shell
root@localhost:~# lsusb
Bus 006 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub
Bus 005 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 004 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub
Bus 003 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub
Bus 001 Device 019: ID 30de:6545
Bus 001 Device 018: ID 0bda:8152 Realtek Semiconductor Corp.
Bus 001 Device 017: ID 214b:7250
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
```

不过在测试过程中，发现接入拓展坞时，如果连接不是很稳定的话，或者刻意松动一下接口，都会出现以下相关信息

```shell
root@localhost:~# [ 1136.593959] usb 3-1: device descriptor read/64, error -71
[ 1138.685934] usb 3-1: device not accepting address 21, error -71
[ 1139.589963] usb usb3-port1: Cannot enable. Maybe the USB cable is bad?
[ 1140.890048] usb 3-1: device descriptor read/8, error -71
[ 1141.022064] usb 3-1: device descriptor read/8, error -71

root@localhost:~# [ 1146.205947] usb 3-1: device descriptor read/64, error -71
[ 1146.861927] usb 3-1: device not accepting address 27, error -71
[ 1149.537976] print_req_error: I/O error, dev sda, sector 122019720
[ 1149.544133] print_req_error: I/O error, dev sda, sector 122019784
[ 1150.449963] usb 3-1: device descriptor read/64, error -71
[ 1151.105933] usb 3-1: device descriptor read/64, error -71
[ 1155.537954] usb 3-1: device descriptor read/64, error -71

root@localhost:~# [ 1161.073624] usb 3-1-port4: cannot reset (err = -71)
[ 1161.092669] scsi 1:0:0:0: rejecting I/O to offline device
[ 1161.098089] scsi 1:0:0:0: rejecting I/O to offline device
[ 1161.103588] print_req_error: I/O error, dev sda, sector 122019720
[ 1161.109738] Buffer I/O error on dev sda, logical block 15252465, async page read
[ 1161.109751] print_req_error: I/O error, dev sda, sector 122019784
[ 1161.123386] Buffer I/O error on dev sda, logical block 512, async page read
[ 1162.197985] usb usb3-port1: Cannot enable. Maybe the USB cable is bad?
[ 1163.437966] usb usb3-port1: Cannot enable. Maybe the USB cable is bad?
[ 1164.661954] usb usb3-port1: Cannot enable. Maybe the USB cable is bad?
[ 1164.865132] usb 3-1: can't set config #1, error -71
[ 1165.897959] usb 3-1: device descriptor read/64, error -71
[ 1166.969944] usb 3-1: device descriptor read/64, error -71
```

而在自研AMR控制器中，接入任何设备都没有反应，只有以下信息

```
root@localhost:~# dmesg|grep usb
[    1.764540] usbcore: registered new interface driver usbfs
[    1.770075] usbcore: registered new interface driver hub
[    1.775459] usbcore: registered new device driver usb
[    3.133762] usbcore: registered new interface driver usb-storage
[    3.349098] usbcore: registered new interface driver usbhid
[    3.354671] usbhid: USB HID core driver
[    4.125139] usb usb1-port1: Cannot enable. Maybe the USB cable is bad?
[    5.033141] usb usb1-port1: Cannot enable. Maybe the USB cable is bad?
[    5.039708] usb usb1-port1: attempt power cycle
[    6.257172] usb usb1-port1: Cannot enable. Maybe the USB cable is bad?
[    7.161142] usb usb1-port1: Cannot enable. Maybe the USB cable is bad?
[    7.167717] usb usb1-port1: unable to enumerate USB device

root@ubuntu:~# lsusb
Bus 006 Device 001: ID 1d6b:0003  
Bus 005 Device 001: ID 1d6b:0002  
Bus 004 Device 001: ID 1d6b:0003  
Bus 003 Device 001: ID 1d6b:0002  
Bus 002 Device 001: ID 1d6b:0003  
Bus 001 Device 001: ID 1d6b:0002  
root@ubuntu:~# [   32.198157] usb usb1-port1: Cannot enable. Maybe the USB cable is bad?
[   33.102150] usb usb1-port1: Cannot enable. Maybe the USB cable is bad?
[   34.322146] usb usb1-port1: Cannot enable. Maybe the USB cable is bad?
[   35.226151] usb usb1-port1: Cannot enable. Maybe the USB cable is bad?
[   35.232781] usb usb1-port1: unable to enumerate USB device
```

demoA和AMR都是USB3.0，两个区别就在于前者是USB type-A，后者是USB type-C，AMR控制器由于是C口，需要具有正反接的功能，所以加入了两块芯片，做于识别正反接，其余的原理图都和demo上是一样的，并且烧录的系统中，已经装载了usb341.ko、usb343.ko、usb210x.ko、pl2303.ko、usbserial.ko，以及内核以及配置了支持usb-storage，所以基本上的驱动都装载了。

目前的问题是：无论接入什么设备lsusb都没有反应

[How can I enable USB type C connectors on 15.10? - Ask Ubuntu](https://askubuntu.com/questions/714169/how-can-i-enable-usb-type-c-connectors-on-15-10)

Steps:

1. Become Root: `sudo su`
2. List `/sys/bus/pci/drivers/xhci_hcd`: `ls -l /sys/bus/pci/drivers/xhci_hcd`

```
root@ubuntu:~# ls -l /sys/bus/pci/drivers/xhci_hcd
total 0
--w------- 1 root root 4096 Mar  2 13:23 bind
--w------- 1 root root 4096 Mar  2 13:23 new_id
--w------- 1 root root 4096 Mar  2 13:23 remove_id
--w------- 1 root root 4096 Mar  2 12:58 uevent
--w------- 1 root root 4096 Mar  2 13:23 unbind
```

[USB Getting *Cannot enable. Maybe the USB cable is bad?* error with multiple devices, but only sometimes - Ask Ubuntu](https://askubuntu.com/questions/1359116/usb-getting-cannot-enable-maybe-the-usb-cable-is-bad-error-with-multiple-dev)

```
lsusb -t
```

```
root@ubuntu:~# lsusb -t
/:  Bus 06.Port 1: Dev 1, Class=root_hub, Driver=xhci-hcd/1p, 5000M
/:  Bus 05.Port 1: Dev 1, Class=root_hub, Driver=xhci-hcd/1p, 480M
/:  Bus 04.Port 1: Dev 1, Class=root_hub, Driver=xhci-hcd/1p, 5000M
/:  Bus 03.Port 1: Dev 1, Class=root_hub, Driver=xhci-hcd/1p, 480M
/:  Bus 02.Port 1: Dev 1, Class=root_hub, Driver=xhci-hcd/1p, 5000M
/:  Bus 01.Port 1: Dev 1, Class=root_hub, Driver=xhci-hcd/1p, 480M
```

[linux type-c driver ubuntu usb usb1-port1: Cannot enable. Maybe the USB cable is bad? - 搜索 (bing.com)](https://www.bing.com/search?q=linux+type-c+driver+ubuntu+usb+usb1-port1%3A+Cannot+enable.+Maybe+the+USB+cable+is+bad%3F&qs=n&form=QBRE&sp=-1&lq=0&pq=linux+type-c+driver+ubuntu+usb+usb1-port1%3A+cannot+enable.+maybe+the+usb+cable+is+bad%3F&sc=0-85&sk=&cvid=F7EE022777144D5DAE71A379BE51AE2B&ghsh=0&ghacc=0&ghpl=)



```bash
ls -lha /sys/bus/usb/devices
```

```
root@ubuntu:~# ls -lha /sys/bus/usb/devices
total 0
drwxr-xr-x 2 root root 0 Mar  2 13:23 .
drwxr-xr-x 4 root root 0 Mar  2 12:58 ..
lrwxrwxrwx 1 root root 0 Mar  2 12:58 1-0:1.0 -> ../../../devices/platform/soc/soc:aux_bus/2f00000.usb/xhci-hcd.0.auto/usb1/1-0:1.0
lrwxrwxrwx 1 root root 0 Mar  2 12:58 2-0:1.0 -> ../../../devices/platform/soc/soc:aux_bus/2f00000.usb/xhci-hcd.0.auto/usb2/2-0:1.0
lrwxrwxrwx 1 root root 0 Mar  2 12:58 3-0:1.0 -> ../../../devices/platform/soc/soc:aux_bus/3000000.usb/xhci-hcd.1.auto/usb3/3-0:1.0
lrwxrwxrwx 1 root root 0 Mar  2 12:58 4-0:1.0 -> ../../../devices/platform/soc/soc:aux_bus/3000000.usb/xhci-hcd.1.auto/usb4/4-0:1.0
lrwxrwxrwx 1 root root 0 Mar  2 12:58 5-0:1.0 -> ../../../devices/platform/soc/soc:aux_bus/3100000.usb/xhci-hcd.2.auto/usb5/5-0:1.0
lrwxrwxrwx 1 root root 0 Mar  2 12:58 6-0:1.0 -> ../../../devices/platform/soc/soc:aux_bus/3100000.usb/xhci-hcd.2.auto/usb6/6-0:1.0
lrwxrwxrwx 1 root root 0 Mar  2 12:58 usb1 -> ../../../devices/platform/soc/soc:aux_bus/2f00000.usb/xhci-hcd.0.auto/usb1
lrwxrwxrwx 1 root root 0 Mar  2 12:58 usb2 -> ../../../devices/platform/soc/soc:aux_bus/2f00000.usb/xhci-hcd.0.auto/usb2
lrwxrwxrwx 1 root root 0 Mar  2 12:58 usb3 -> ../../../devices/platform/soc/soc:aux_bus/3000000.usb/xhci-hcd.1.auto/usb3
lrwxrwxrwx 1 root root 0 Mar  2 12:58 usb4 -> ../../../devices/platform/soc/soc:aux_bus/3000000.usb/xhci-hcd.1.auto/usb4
lrwxrwxrwx 1 root root 0 Mar  2 12:58 usb5 -> ../../../devices/platform/soc/soc:aux_bus/3100000.usb/xhci-hcd.2.auto/usb5
lrwxrwxrwx 1 root root 0 Mar  2 12:58 usb6 -> ../../../devices/platform/soc/soc:aux_bus/3100000.usb/xhci-hcd.2.auto/usb6
```

从启动信息上看，AMR比demo缺少的一些信息如下：

```
{    2.874637] usb usb1: New USB device found, idVendor=1d6b, idProduct=0002
[    2.881433] usb usb1: New USB device strings: Mfr=3, Product=2, SerialNumber=1
[    2.888660] usb usb1: Product: xHCI Host Controller
[    2.893540] usb usb1: Manufacturer: Linux 4.14.83 xhci-hcd
[    2.899052] usb usb1: SerialNumber: xhci-hcd.0.auto
......
[    2.931753] usb usb2: New USB device found, idVendor=1d6b, idProduct=0003
[    2.938547] usb usb2: New USB device strings: Mfr=3, Product=2, SerialNumber=1
[    2.945773] usb usb2: Product: xHCI Host Controller
[    2.950653] usb usb2: Manufacturer: Linux 4.14.83 xhci-hcd
[    2.956139] usb usb2: SerialNumber: xhci-hcd.0.auto
......
[    2.997025] usb usb3: New USB device found, idVendor=1d6b, idProduct=0002
[    3.003817] usb usb3: New USB device strings: Mfr=3, Product=2, SerialNumber=1
[    3.011044] usb usb3: Product: xHCI Host Controller
[    3.015924] usb usb3: Manufacturer: Linux 4.14.83 xhci-hcd
[    3.021412] usb usb3: SerialNumber: xhci-hcd.1.auto
```





重新搭建电路，使用USB type A口后，接入设备，会报一个usb的错误：

```
root@ubuntu:~# [  351.202367] usb 1-1: device descriptor read/64, error -71
[  351.442357] usb 1-1: device descriptor read/64, error -71
[  351.810365] usb 1-1: device descriptor read/64, error -71
[  352.050364] usb 1-1: device descriptor read/64, error -71
[  353.230345] usb 1-1: device not accepting address 8, error -71
```

源代码中的-71(/include/asm-generic/erro.h)代表的是协议的错误

解决方案1：

```
echo -1 > /sys/module/usbcore/parameters/autosuspend
```

方案1失败

解决方案2：协议的错误应该就是时序的错误，时序的错误就代表了硬件走线应该是有问题，

看看把到USB端口的线做的很短，能不能解决问题？

[linux-3.2.0 usb出现device descriptor read/64, error -71问题求助 - 处理器论坛 - 处理器 - E2E™ 设计支持 (ti.com)](https://e2echina.ti.com/support/processors/f/processors-forum/185637/linux-3-2-0-usb-device-descriptor-read-64-error--71)

[USB调试的错误 device descriptor read/64, error -71 已解决-CSDN博客](https://blog.csdn.net/tiny_pi/article/details/20529219?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-20529219-blog-131194524.235^v38^pc_relevant_anti_vip_base&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-20529219-blog-131194524.235^v38^pc_relevant_anti_vip_base&utm_relevant_index=1)

```
root@ubuntu:~# echo Y > /sys/module/usbcore/parameters/old_scheme_first
root@ubuntu:~# cat /sys/module/usbcore/parameters/old_scheme_first
Y
```

进行以上操作后，错误增加如下：

```
root@ubuntu:~# [ 1231.042347] usb 1-1: device not accepting address 18, error -71
[ 1231.590347] usb 1-1: device not accepting address 19, error -71
[ 1232.374365] usb 1-1: device descriptor read/64, error -71
[ 1232.614364] usb 1-1: device descriptor read/64, error -71
[ 1232.982368] usb 1-1: device descriptor read/64, error -71
[ 1233.222365] usb 1-1: device descriptor read/64, error -71
[ 1233.334387] usb usb1-port1: unable to enumerate USB device
```

d+ d-数据线一定要使用屏蔽线并尽量短，否则会不稳定？

[USB电路接口线序及故障排除_urb status -71-CSDN博客](https://jiazhen.blog.csdn.net/article/details/86534982?spm=1001.2101.3001.6650.15&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-15-86534982-blog-20529219.235^v38^pc_relevant_anti_vip_base&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-15-86534982-blog-20529219.235^v38^pc_relevant_anti_vip_base&utm_relevant_index=16)

跨过多余的两个芯片，直接连接到座子上，测试，无论是USB2.0的座子还是USB3.0的，都还是之前的问题，无法解决。

##### 目前识别方案：

从ls1046芯片出来b2b的引脚直接连接到座子，不经过底板（2023/11/24）

```
Disk /dev/mmcblk0: 29.8 GiB, 31927042048 bytes, 62357504 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x4298b40a

Device         Boot    Start      End  Sectors  Size Id Type
/dev/mmcblk0p1        139264   344063   204800  100M 83 Linux
/dev/mmcblk0p2        346112  2443263  2097152    1G 83 Linux
/dev/mmcblk0p3       2445312 15028223 12582912    6G 83 Linux
/dev/mmcblk0p4      15030272 62357503 47327232 22.6G 83 Linux


Disk /dev/sdb: 58.6 GiB, 62914560000 bytes, 122880000 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x00000000

Device     Boot Start       End   Sectors  Size Id Type
/dev/sdb1       32768 122879999 122847232 58.6G  7 HPFS/NTFS/exFAT
```

```
Device     Boot Start       End   Sectors   Size Id Type
/dev/sda1        2048 250069679 250067632 119.2G 83 Linux


Disk /dev/mmcblk0: 29.8 GiB, 31927042048 bytes, 62357504 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x4298b40a

Device         Boot    Start      End  Sectors  Size Id Type
/dev/mmcblk0p1        139264   344063   204800  100M 83 Linux
/dev/mmcblk0p2        346112  2443263  2097152    1G 83 Linux
/dev/mmcblk0p3       2445312 15028223 12582912    6G 83 Linux
/dev/mmcblk0p4      15030272 62357503 47327232 22.6G 83 Linux


Disk /dev/sdb: 7.5 GiB, 8053063680 bytes, 15728640 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x01ab86c7

Device     Boot Start      End  Sectors  Size Id Type
/dev/sdb1  *       64 15728639 15728576  7.5G  b W95 FAT32
```

8GU盘和64GU盘均能识别了，其余还没测试







## 附录：一些打印信息所处的位置

| 打印信息                                                     | 源文件                                                       | 函数                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Model: GIE LS1046A FRWY Board                                | u-boot/common/board_info.c                                   | show_board_info(void)                                        |
| Board: LS1046AFRWY, Rev: A, boot from SD                     | u-boot/board/freescale/ls1046afrwy/ls1046afrwy.c             | checkboard(void)                                             |
| SD1_CLK1 = 100.00MHZ, SD1_CLK2 = 100.00MHZ                   | 同上                                                         | 同上                                                         |
| I2C:   ready                                                 | u-boot/common/board_f.c                                      | init_func_i2c(void)                                          |
| DRAM:  3.9 GiB (DDR4, 64-bit, CL=15, ECC on)                 | 1.u-boot/common/board_f.c<br />2.u-boot/drivers/ddr/fsl/util.c | 1.announce_dram_init<br />2.show_dram_config(void)<br />3.print_ddr_info |
| SEC0: RNG instantiated                                       | u-boot/drivers/crypto/fsl/jr.c                               |                                                              |
| PCA: failed to select proper channel                         | u-boot/board/freescale/ls1046afrwy/ls1046afrwy.c             | select_i2c_ch_pca9547(u8 ch)                                 |
| Using SERDES1 Protocol: 13107 (0x3333)                       | u-boot/arch/arm/cpu/armv8/fsl-layerscape/fsl_lsch2_serdes.c  | serdes_init                                                  |
| Using SERDES2 Protocol: 21849 (0x5559)                       | 同上                                                         | 同上                                                         |
| NAND:  512 MiB                                               | u-boot/common/board_r.c                                      | initr_nand(void)                                             |
| MMC:   FSL_SDHC: 0                                           | 同上                                                         | 1.initr_mmc(void)<br />2.fsl_esdhc_mmc_init                  |
| Loading Environment from MMC...                              | 1.u-boot/env/common.c<br />2.u-boot/env/env.c<br />          | 1.initr_env<br />2.env_relocate<br />3.env_load(void)<br />  |
| *** Warning - bad CRC, using default environment             | u-boot/env/common.c                                          | set_default_env                                              |
| EEPROM: Read failed.                                         | /u-boot/board/freescale/common/sys_eeprom.c                  | mac_read_from_eeprom                                         |
| In:    serial<br/>Out:   serial<br/>Err:   serial            | 1.u-boot/common/board_r.c<br />2.u-boot/common/console.c     | 1.console_init_r<br />2.stdio_print_current_devices          |
| Net:                                                         | 1.u-boot/common/board_r.c<br />2.u-boot/net/eth_legacy.c<br />3.u-boot/net/eth_common.c | 1.initr_net<br />2.eth_initialize<br />3.eth_common_init<br />4.详细查看上方有线网口解析 |
| MMC read: dev # 0, block # 18432, count 128                  | u-boot/drivers/net/fm/fm.c                                   | fman_upload_firmware                                         |
| Fman1: Uploading microcode version 106.4.18                  | u-boot/drivers/net/fm/fm.c                                   | 1.fm_init_common<br />2.fman_upload_firmware                 |
| FSL_MDIO0:3 is connected to FM1@DTSEC3.  Reconnecting to FM1@DTSEC6 | u-boot/drivers/net/phy/phy.c                                 | phy_connect_dev                                              |
| PCIe0: pcie@3400000 Root Complex: no link                    | u-boot/drivers/pci/pcie_layerscape.c                         | ls_pcie_probe                                                |
| , FM1@DTSEC5 [PRIME]<br/>Warning: FM1@DTSEC5 (eth2) using random MAC address - 42:c2:e0:81:6e:b6 | u-boot/net/eth-uclass.c/u-boot/net/eth_legacy.c              | 1.eth_initialize<br />2.eth_post_probe/eth_write_hwaddr      |
| Hit any key to stop autoboot:                                | u-boot/common/autoboot.c                                     | int __abortboot(int bootdelay)                               |



## 附录：系统日志说明

```
/var/log/messages或/var/log/syslog — 包括整体系统信息，其中也包含系统启动期间的日志。此外，mail，cron，daemon，kern和auth等内容也记录在var/log/messages日志中。
/var/log/dmesg — 包含内核缓冲信息（kernel ring buffer）。在系统启动时，会在屏幕上显示许多与硬件有关的信息。可以用dmesg查看它们。
/var/log/auth.log — 包含系统授权信息，包括用户登录和使用的权限机制等。
/var/log/boot.log — 包含系统启动时的日志。
/var/log/daemon.log — 包含各种系统后台守护进程日志信息。
/var/log/dpkg.log — 包括安装或dpkg命令清除软件包的日志。
/var/log/kern.log — 包含内核产生的日志，有助于在定制内核时解决问题。
/var/log/lastlog — 记录所有用户的最近信息。这不是一个ASCII文件，因此需要用lastlog命令查看内容。
/var/log/maillog 与 /var/log/mail.log — 包含来着系统运行电子邮件服务器的日志信息。例如，sendmail日志信息就全部送到这个文件中。
/var/log/user.log — 记录所有等级用户信息的日志。
/var/log/Xorg.x.log — 来自X的日志信息。
/var/log/alternatives.log — 更新替代信息都记录在这个文件中。
/var/log/btmp — 记录所有失败登录信息。使用last命令可以查看btmp文件。例如，last -f /var/log/btmp | more 。
/var/log/cups — 涉及所有打印信息的日志。
/var/log/anaconda.log — 在安装Linux时，所有安装信息都储存在这个文件中。
/var/log/yum.log — 包含使用yum安装的软件包信息。
/var/log/cron — 每当cron进程开始一个工作时，就会将相关信息记录在这个文件中。
/var/log/secure — 包含验证和授权方面信息。例如，sshd会将所有信息记录（其中包括失败登录）在这里。
/var/log/wtmp或/var/log/utmp — 包含登录信息。使用wtmp可以找出谁正在登陆进入系统，谁使用命令显示这个文件或信息等。
/var/log/faillog —包含用户登录失败信息。此外，错误登录命令也会记录在本文件中。
```

```
tail -f /var/log/syslog
```



