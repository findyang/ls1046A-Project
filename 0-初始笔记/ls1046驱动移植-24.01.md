由于linux驱动调试需要的时间是不确定因素，所以接下来的篇章是以不同驱动部分分类，里面再加入时间节点说明。

### 汇总需要适配及测试的外设

截止2023/11/27

1. 有线网口（能识别到设备，但是ping不通）（1.22完成RGMII调试）
2. qspi nor flash（不能识别到设备）
3. 无线wifi模块（12/19完成驱动移植，待完成模块识别然后测试）（已成功联网但不稳定(2024.1.9)）
4. 固态硬盘（已完成）
5. 板载emmc
6. nand flash（优先级低，因为ls1046无法从nand启动，作为存储又没有固态硬盘容量大）
7. usb type-c（已完成USB2.0的功能，待完成USB3.0）（截止至11/29，目前USB2.0和USB3.0、type-c的功能均以能使用，还差第三路USB使能）（12/12-12/15解决USB第三路问题）

并且以上有些外设使能还分为uboot阶段和系统内核驱动阶段

| 外设           | uboot使用场景                                    | 系统阶段使用场景                                   |
| -------------- | ------------------------------------------------ | -------------------------------------------------- |
| 有线网口       | tftp下载镜像，固化系统                           | 与AM3354通信、网络通信                             |
| qspi nor flash | 系统启动                                         | ramdisk系统                                        |
| 无线wifi模块   | 暂无，这个阶段可以先做识别                       | 网络通信                                           |
| 固态硬盘       | 暂无，不过需要这个阶段就识别来启动ubuntu1804系统 | ubuntu1804系统                                     |
| 板载emmc       | 系统启动                                         | ubuntu1804系统                                     |
| nand flash     | 暂无，1046A无法使用nand启动                      | 可以启动挂载ubuntu1804系统，不过容量比不上固态硬盘 |
| usb type-c     | 暂无                                             | 与AM3354通信、雷达通信、stm32底板通信、U盘等       |







### USB驱动(已完成)

截止至11/29，目前USB2.0和USB3.0、type-c的功能均以能使用

```
识别使用过程问题以及解决方式：
无法识别USB-->信号线上的电阻去掉即可识别(原本用于防干扰的，不知道为什么去掉才能识别USB)
只能使用USB2.0-->USB3.0原理图上接收和发送画反了，修改即可使用USB3.0的功能
USB type-c无法正反接-->焊接问题，芯片短接了，重新焊接即可
第三路USB无法使用，电平为低，正常为高-->未解决
```

如何使能第三路USB，参考以下链接（目前测试结果为失败）

[Solved: LS1046A How to enable I2C4 automatically in RCW - NXP Community](https://community.nxp.com/t5/Layerscape/LS1046A-How-to-enable-I2C4-automatically-in-RCW/m-p/1367299)

根据原文链接翻译如下：

> LS1046a RCW没有用于I2C4引脚分配的位。
>
> 使用DEVDISR5寄存器。请参见《LS1046a参考手册》12.3.10章节。
>
> 使用SCFG_RCWPMUXCR0寄存器。参见11.3.41节。

> 你好帕维尔,
>
> 是的，我理解那些寄存器。我的问题是如何在RCW中启用这些功能?
>
> 我注意到有一个pbi部分，允许我发送一些命令。
>
> 下面是我的命令格式。 write 0x0157040C, 0x00000000. 但这行不通。
>
> 我对如何使能I2C4的理解有误吗?

> 将.pbl写入RCW。附带的文件包含使能I2C4引脚的RCW示例。
>
> 该文件在LSDK 2108中的路径如下:
>
> flexbuild_lsdk2108/components/firmware/rcw/ls1046ardb/RR_FFSSPPPH_1133_5559
>
> 请参阅以下文件中用于构建的文件的信息:
>
> flexbuild_lsdk2108/configs/board/ls1046ardb/manifest
>
> 使用以下命令序列构建RCW、ATF和.img:
>
> flex-builder -c rcw -m ls1046ardb -b sd
>
> flex-builder -c atf -m ls1046ardb -b sd
>
> flex-builder -i mkfw -m ls1046ardb -b sd

数据手册第432页对应关系如下：

| 25–27    | Configures functionality of the IIC4_SCL                     |
| -------- | ------------------------------------------------------------ |
| IIC4_SCL | 000 IIC4_SCL<br/>001 GPIO_4[12]<br/>010 EVT_B[7]<br/>011 USB3_DRVVBUS<br/>100 Reserved<br/>101 FTM3_FAULT<br/>110 Reserved<br/>111 IIC4_SCL<br/>NOTE: Refer USB_DRVVBUS_SELCR register for USB3_DRV_VBUS to USB Controller mapping |

值得注意的是部分管脚是通过SCFG_RCWPMUXCR0 这个寄存器来配置。数据手册第389页如下得到地址为157_040C ：

| 157_040C | Extended RCW PinMux Control Register<br />(SCFG_RCWPMUXCR0) | 32   | R/W  | 0000_1111h | 11.3.41/431 |
| -------- | ----------------------------------------------------------- | ---- | ---- | ---------- | ----------- |

在RCW中根据其他参考和链接源文件的参考，写入的地址值应为0x57040C，根据432页，011 USB3_DRVVBUS，011 USB3_PWRFAULT，设置00110011=0x33，最终如下：

```
.pbi
// USB3_DRVVBUS
write 0x57040C,0x00000033
.end
```

烧录系统进行测试，电平为低，启用失败。

| 157_0000 - 157_FFFF | Supplemental Configuration Unit(SCFG) | Big-endian (byte swapping required) |
| ------------------- | ------------------------------------- | ----------------------------------- |

后续更正，32bit应为（大端）0x00330000:00000000001100110000000000000000

所以应该是RCW是小端，write 0x57040C,0x00003300，如果要设置第二、三路USB，应该是0x33330000:
00000010001100110000000000000000，write 0x57040C,0x00003333

默认的输出是

```
=> md 0x157040C
0157040c: 00330000 00000000 09000000 9e000000    ..3.............
0157041c: 9e000000 9e000000 000000f0 0000f8ff    ................
```

如果正确写入的话，应该是0157040c: 33330000，进行烧录测试



> 在 RCW 源文件中虽然有定义 512 位的字段和字段名但是并没有将所有的字段定义列举 出来，有些字段是保留项省略了，如果需要更改这些字段可以根据 QorIQ LS1043A Reference Manual 中第四章节中的 RCW 字段表格中描述的进行修改，按照前面的格式添加到源文件中。
>

根据以上RCW添加如下：

```
IIC4_SCL=3
```

进行测试仍然无法使能USB3

[am335x usb 问题 DRVVBUS 一直是低 - 处理器论坛 - 处理器 - E2E™ 设计支持 (ti.com)](https://e2echina.ti.com/support/processors/f/processors-forum/147276/am335x-usb-drvvbus)



[Solved: USB Over Current Condition in LS1046 - NXP Community](https://community.nxp.com/t5/Layerscape/USB-Over-Current-Condition-in-LS1046/m-p/1253979)

> 在u-boot中，SCFG_USBPWRFAULT_SELCR寄存器的默认配置是0x2900_0000(大端)。
>
> 这意味着USB1, USB2和USB3控制器从专用的USBx_PWRFAULT I/O接收PWRFAULT。
>
> USB3_PWRFAULT信号不使用，该引脚分配给TDMB_RQ。参见LS1043ARDB原理图。

```
=> md 0x157040C
0157040c: 00330000 00000000 09000000 9e000000    ..3.............
0157041c: 9e000000 9e000000 000000f0 0000f8ff    ................
=> md 0x1570414
01570414: 29000000 9e000000 9e000000 9e000000    ...)............
01570424: 000000f0 0000f8ff 00000000 00000000    ................
=> md 0x1570604
01570604: 00000010 00000000 00000000 00000000    ................
01570614: 00000000 00000000 00000000 00000000    ................
=> md 0x1570178
01570178: 10e00000 ffffffff 01020000 00000000    ................
01570188: 06000000 0000800a 29000000 29000000    ...........)...)

```

在RCW源文件上的设置为

```
write 0x570418, 0x0000009e
write 0x57041c, 0x0000009e
write 0x570420, 0x0000009e
```

从两边分析，在RCW源文件中是以小端写入，在内存上存储是大端

在分析时，从31bit填写到0bit，比如00101001000000000000000000000000，然后转成16进制0x29000000（大端），小端则是0x00000029



寄存器值（大端）解析：

```
0x29000000:
00101001000000000000000000000000
0x09000000:
00001001000000000000000000000000

0x00330000:
0000 0000 0011 0011 0000000000000000
0x33330000
0011 0011 0011 0011 0000000000000000
0x02330000:

0x9e000000：
10011110000000000000000000000000
```

写入、读出操作：

```
mw 0x1570414 0x29000000
md 0x1570414

mw 0x157040C 0x33330000
md 0x157040C

mw 0x1570410 0xC0000000
md 0x1570410
```



[LS1046A does not detect USB stick - NXP Community](https://community.nxp.com/t5/Layerscape/LS1046A-does-not-detect-USB-stick/m-p/1661669)

> USBx_PWRFAULT、USB_DRVVBUS USBx_PWRFAULT。
>
> 检查三个信号包括rcw配置和检查表要求。

在硬件电路上直接上拉第三路USB的USB_DRVVBUS ，接入设备显示信息如下：

```
root@ubuntu:~# [   53.356188] usb 5-1: device descriptor read/64, error -71
[   53.596186] usb 5-1: device descriptor read/64, error -71
[   53.964185] usb 5-1: device descriptor read/64, error -71
[   54.204185] usb 5-1: device descriptor read/64, error -71

root@ubuntu:~# [   55.384168] usb 5-1: device not accepting address 8, error -71
[   55.932169] usb 5-1: device not accepting address 9, error -71
[   55.938052] usb usb5-port1: unable to enumerate USB device
```

现在至少能检测到有设备接入，但是不清楚这样的解决方式存在什么问题

未上拉电平的底板，在uboot上测试usb，结果如下：

```
=> usb start
starting USB...
USB0:   Register 200017f NbrPorts 2
Starting the controller
USB XHCI 1.00
USB1:   Register 200017f NbrPorts 2
Starting the controller
USB XHCI 1.00
USB2:   Register 200017f NbrPorts 2
Starting the controller
USB XHCI 1.00
scanning bus 0 for devices... 1 USB Device(s) found
scanning bus 1 for devices... 3 USB Device(s) found
scanning bus 2 for devices... 1 USB Device(s) found
       scanning usb for storage devices... 1 Storage Device(s) found
=> usb start
=> usb start
=> usb reset
resetting USB...
USB0:   Register 200017f NbrPorts 2
Starting the controller
USB XHCI 1.00
USB1:   Register 200017f NbrPorts 2
Starting the controller
USB XHCI 1.00
USB2:   Register 200017f NbrPorts 2
Starting the controller
USB XHCI 1.00
scanning bus 0 for devices... 1 USB Device(s) found
scanning bus 1 for devices... 1 USB Device(s) found
scanning bus 2 for devices... 1 USB Device(s) found
       scanning usb for storage devices... 0 Storage Device(s) found
=> usb reset
resetting USB...
USB0:   Register 200017f NbrPorts 2
Starting the controller
USB XHCI 1.00
USB1:   Register 200017f NbrPorts 2
Starting the controller
USB XHCI 1.00
USB2:   Register 200017f NbrPorts 2
Starting the controller
USB XHCI 1.00
scanning bus 0 for devices... 1 USB Device(s) found
scanning bus 1 for devices... 2 USB Device(s) found
scanning bus 2 for devices... 1 USB Device(s) found
       scanning usb for storage devices... 0 Storage Device(s) found
=> usb reset
resetting USB...
USB0:   Register 200017f NbrPorts 2
Starting the controller
USB XHCI 1.00
USB1:   Register 200017f NbrPorts 2
Starting the controller
USB XHCI 1.00
USB2:   Register 200017f NbrPorts 2
Starting the controller
USB XHCI 1.00
scanning bus 0 for devices... 2 USB Device(s) found
scanning bus 1 for devices... 1 USB Device(s) found
scanning bus 2 for devices... 1 USB Device(s) found
       scanning usb for storage devices... 0 Storage Device(s) found
=> usb reset
resetting USB...
USB0:   Register 200017f NbrPorts 2
Starting the controller
USB XHCI 1.00
USB1:   Register 200017f NbrPorts 2
Starting the controller
USB XHCI 1.00
USB2:   Register 200017f NbrPorts 2
Starting the controller
USB XHCI 1.00
scanning bus 0 for devices... 1 USB Device(s) found
scanning bus 1 for devices... 1 USB Device(s) found
scanning bus 2 for devices... 1 USB Device(s) found
       scanning usb for storage devices... 0 Storage Device(s) found
```

在uboot中使用usb命令scan设备，测试结果为第一路和第二路USB都能识别到设备并且识别成功到存储设备，第三路USB识别失败

上拉电平的底板，在uboot上测试usb，测试结果如下：

```
=> usb reset
resetting USB...
USB0:   Register 200017f NbrPorts 2
Starting the controller
USB XHCI 1.00
USB1:   Register 200017f NbrPorts 2
Starting the controller
USB XHCI 1.00
USB2:   Register 200017f NbrPorts 2
Starting the controller
USB XHCI 1.00
scanning bus 0 for devices... 1 USB Device(s) found
scanning bus 1 for devices... 1 USB Device(s) found
scanning bus 2 for devices... Device not responding to set address.

      USB device not accepting new address (error=80000000)
1 USB Device(s) found
       scanning usb for storage devices... 0 Storage Device(s) found

```

在接入第三路USB时，报错Device not responding to set address.

#### 最终解决：

USB_DRVVBUS：USB设备的电源线，用于提供USB1接口所需的电源。USB_DRVVBUS是USB设备的电源线，它用于接收来自主机的电源信号，以供给USB设备所需的电源。当USB设备被连接到主机时，主机会通过USB_DRVVBUS线向设备提供电源。USB设备会通过检测USB_DRVVBUS线上的电压来确定是否有足够的电源供应。这是输出脚，给电平信号到EN使能引脚上。

USB1_VBUS是USB接口1的电源线，它提供USB设备所需的电源。当USB设备连接到特定的USB接口1时，USB1_VBUS线会向设备提供电源。USB设备会通过检测USB1_VBUS线上的电压来确定是否有足够的电源供应。

USB_PWRFAULT是USB设备的电源故障检测线，用于检测USB设备的电源是否正常。当USB设备的电源出现故障时，USB_PWRFAULT会发送信号给主机，通知主机设备的电源状态。区别在于USB_PWRFAULT是用于检测设备电源故障的线路，而USB_DRVVBUS和USB1_VBUS是用于提供设备电源的线路。

问题还是SCFG_RCWPMUXCR0这个寄存器的值写入错误、在uboot终端修改的值被重启导致值失效以及在RCW写入的值会被uboot中覆盖。

1. 在12月12号这个时候测试，思路是先禁用USB2，使能USB3，来做对比，但是不知道为什么RCW上写入的值失败（原因：./board/freescale/ls1046afrwy/ls1046afrwy.c:    out_be32(&scfg->rcwpmuxcr0, 0x3300);    应该是因为这里有重新给他赋值 ）
2. 在uboot阶段上进行修改但是写入了错误的值，读出来是0x02330000（内存上大端显示）
3. 写入了正确的值0x33330000（大端）的时候，这个值是正确的，但是因为我测试的板卡不稳定，它会重启一次，导致我之前在uboot终端写入的值失效了

最终解决修改如下：

```diff
//u-boot/board/freescale/ls1046afrwy/ls1046afrwy.c 第196行
#ifdef CONFIG_HAS_FSL_XHCI_USB
	struct ccsr_scfg *scfg = (struct ccsr_scfg *)CONFIG_SYS_FSL_SCFG_ADDR;
	u32 usb_pwrfault;
-out_be32(&scfg->rcwpmuxcr0, 0x3300);
+out_be32(&scfg->rcwpmuxcr0, 0x3333);
```

测试如下：

```
root@ubuntu:~# lsusb
Bus 006 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub
Bus 005 Device 005: ID 0bda:b812 Realtek Semiconductor Corp.
Bus 005 Device 004: ID 1a40:0101 Terminus Technology Inc. Hub
Bus 005 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 004 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub
Bus 003 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
root@ubuntu:~# lsusb
Bus 006 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub
Bus 005 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 004 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub
Bus 003 Device 003: ID 0bda:b812 Realtek Semiconductor Corp.
Bus 003 Device 002: ID 1a40:0101 Terminus Technology Inc. Hub
Bus 003 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
root@ubuntu:~# lsusb
Bus 006 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub
Bus 005 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 004 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub
Bus 003 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub
Bus 001 Device 003: ID 0bda:b812 Realtek Semiconductor Corp.
Bus 001 Device 002: ID 1a40:0101 Terminus Technology Inc. Hub
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
```

三路USB均已经测试完成





### qspi nor flash驱动

百问网 4-2_SPI_FLASH驱动_调试

从这个视频学一些反汇编的调试使用





### 有线网口

mark：在调试USB WIFI模块时，在up设备后但未执行以下指令时

```
sudo wpa_supplicant -B -iwlx7cdd901b2360 -c/etc/wpa_supplicant/wpa_supplicant.conf
```

状态也是flags=4099<UP,BROADCAST,MULTICAST>

缺少RUNNING状态标志位，但是up设备后并执行完以上的指令后，状态才会变得正常，这个时候状态会增加RUNNING状态标志位，wifi模块才能正常使用，不清楚网口会不会缺少一个类似的流程。

```
mdio0: mdio@fc000 {
		#address-cells = <1>;
		#size-cells = <0>;
		compatible = "fsl,fman-memac-mdio", "fsl,fman-xmdio";
		reg = <0xfc000 0x1000>;
	};
ethernet@e4000 {
		cell-index = <2>;
		compatible = "fsl,fman-memac";
		reg = <0xe4000 0x1000>;
		fsl,fman-ports = <&fman0_rx_0x0a &fman0_tx_0x2a>;
		ptp-timer = <&ptp_timer0>;
		pcsphy-handle = <&pcsphy2>;
	};
```

查看"fsl,fman-memac-mdio"和"fsl,fman-memac"对应的驱动源代码

/home/forlinx/nxp/flexbuild_lsdk1906/packages/linux/linux/drivers/net/ethernet/freescale/fman/mac.c

```
static const struct of_device_id mac_match[] = {
	{ .compatible	= "fsl,fman-dtsec" },
	{ .compatible	= "fsl,fman-xgec" },
	{ .compatible	= "fsl,fman-memac" },
	{}
};
```

/home/forlinx/nxp/flexbuild_lsdk1906/packages/linux/linux/drivers/net/ethernet/freescale/xgmac_mdio.c

```
static const struct of_device_id xgmac_mdio_match[] = {
	{
		.compatible = "fsl,fman-xmdio",
	},
	{
		.compatible = "fsl,fman-memac-mdio",
	},
	{},
};
```

/home/forlinx/nxp/flexbuild_lsdk1906/packages/linux/linux/drivers/net/phy/mdio_bus.c

```
int __mdiobus_register(struct mii_bus *bus, struct module *owner)
{
	struct mdio_device *mdiodev;
	int i, err;
	struct gpio_desc *gpiod;

	if (NULL == bus || NULL == bus->name ||
	    NULL == bus->read || NULL == bus->write)
		return -EINVAL;

	BUG_ON(bus->state != MDIOBUS_ALLOCATED &&
	       bus->state != MDIOBUS_UNREGISTERED);

	bus->owner = owner;
	bus->dev.parent = bus->parent;
	bus->dev.class = &mdio_bus_class;
	bus->dev.groups = NULL;
	dev_set_name(&bus->dev, "%s", bus->id);

	err = device_register(&bus->dev);
	if (err) {
		pr_err("mii_bus %s failed to register\n", bus->id);
		return -EINVAL;
	}

	mutex_init(&bus->mdio_lock);

	/* de-assert bus level PHY GPIO reset */
	gpiod = devm_gpiod_get_optional(&bus->dev, "reset", GPIOD_OUT_LOW);
	if (IS_ERR(gpiod)) {
		dev_err(&bus->dev, "mii_bus %s couldn't get reset GPIO\n",
			bus->id);
		device_del(&bus->dev);
		return PTR_ERR(gpiod);
	} else	if (gpiod) {
		bus->reset_gpiod = gpiod;

		gpiod_set_value_cansleep(gpiod, 1);
		udelay(bus->reset_delay_us);
		gpiod_set_value_cansleep(gpiod, 0);
	}

	if (bus->reset)
		bus->reset(bus);

	for (i = 0; i < PHY_MAX_ADDR; i++) {
		if ((bus->phy_mask & (1 << i)) == 0) {
			struct phy_device *phydev;

			phydev = mdiobus_scan(bus, i);
			if (IS_ERR(phydev) && (PTR_ERR(phydev) != -ENODEV)) {
				err = PTR_ERR(phydev);
				goto error;
			}
		}
	}

	mdiobus_setup_mdiodev_from_board_info(bus, mdiobus_create_device);

	bus->state = MDIOBUS_REGISTERED;
	pr_info("%s: probed\n", bus->name);
	return 0;

error:
	while (--i >= 0) {
		mdiodev = bus->mdio_map[i];
		if (!mdiodev)
			continue;

		mdiodev->device_remove(mdiodev);
		mdiodev->device_free(mdiodev);
	}

	/* Put PHYs in RESET to save power */
	if (bus->reset_gpiod)
		gpiod_set_value_cansleep(bus->reset_gpiod, 1);

	device_del(&bus->dev);
	return err;
}
```

上面代码中`pr_info("%s: probed\n", bus->name);`，而在xgmac_mdio.c文件中第260行

`bus->name = "Freescale XGMAC MDIO Bus";`

从启动日志上看，已经输出了这部分的信息

```
libphy: Fixed MDIO Bus: probed
[    2.528512] tun: Universal TUN/TAP device driver, 1.6
[    2.534292] libphy: Freescale XGMAC MDIO Bus: probed
[    2.539796] libphy: Freescale XGMAC MDIO Bus: probed
[    2.544859] libphy: Freescale XGMAC MDIO Bus: probed
```

说明mdio总线驱动是没有问题的

[以太网驱动的流程浅析(五)-mii_bus初始化以及phy id的获取 (wowotech.net)](http://www.wowotech.net/linux_kenrel/470.html)

```
mdio@fc000 {
    #address-cells = <0x1>;
    #size-cells = <0x0>;
    compatible = "fsl,fman-memac-mdio", "fsl,fman-xmdio";
    reg = <0xfc000 0x1000>;

    ethernet-phy@1 {
            reg = <0x1>;
            reset-gpios = <0x1d 0x1f 0x1>;
            reset-delay-us = <0x30d40>;
            linux,phandle = <0x27>;
            phandle = <0x27>;
    };

    ethernet-phy@2 {
            reg = <0x2>;
            reset-gpios = <0x1d 0x1f 0x1>;
            reset-delay-us = <0x30d40>;
            linux,phandle = <0x2b>;
            phandle = <0x2b>;
    };

    ethernet-phy@3 {
            reg = <0x3>;
            reset-gpios = <0x1d 0x1f 0x1>;
            reset-delay-us = <0x30d40>;
            linux,phandle = <0x37>;
            phandle = <0x37>;
    };

    ethernet-phy@4 {
            reg = <0x4>;
            reset-gpios = <0x1d 0x1f 0x1>;
            reset-delay-us = <0x30d40>;
            linux,phandle = <0x2f>;
            phandle = <0x2f>;
    };

    ethernet-phy@5 {
            reg = <0x5>;
            reset-gpios = <0x1d 0x1f 0x1>;
            reset-delay-us = <0x30d40>;
            linux,phandle = <0x33>;
            phandle = <0x33>;
    };
};
```

/home/forlinx/nxp/flexbuild_lsdk1906/packages/linux/linux/Documentation/devicetree/bindings/net/fsl-fman.txt

第385行开始说明FMan MDIO Node

其中并没有reset-gpios 、reset-delay-us 等属性的介绍，说明应该这部分的驱动并不能涉及到reset，并且fsl-fman.txt该文件全局搜索reset结果是无，fman.txt已经包含了fsl,fman、fsl,fman-mdio、fsl,fman-memac、fsl,fman-memac-mdio等的说明。

```
ethernet@e4000 {
        cell-index = <0x2>;
        compatible = "fsl,fman-memac";
        reg = <0xe4000 0x1000>;
        fsl,fman-ports = <0x24 0x25>;
        ptp-timer = <0x1c>;
        pcsphy-handle = <0x26>;
        phy-handle = <0x27>;
        phy-connection-type = "rgmii";
        linux,phandle = <0x3d>;
        phandle = <0x3d>;
};

mdio@e5000 {
        #address-cells = <0x1>;
        #size-cells = <0x0>;
        compatible = "fsl,fman-memac-mdio", "fsl,fman-xmdio";
        reg = <0xe5000 0x1000>;

        ethernet-phy@0 {
                reg = <0x0>;
                linux,phandle = <0x26>;
                phandle = <0x26>;
        };
};

mdio@fc000 {
        #address-cells = <0x1>;
        #size-cells = <0x0>;
        compatible = "fsl,fman-memac-mdio", "fsl,fman-xmdio";
        reg = <0xfc000 0x1000>;

        ethernet-phy@1 {
                reg = <0x1>;
                reset-gpios = <0x1d 0x1f 0x1>;
                reset-delay-us = <0x30d40>;
                linux,phandle = <0x27>;
                phandle = <0x27>;
        };
```

[[LS1046\] RGMII initialization - NXP Community](https://community.nxp.com/t5/Layerscape/LS1046-RGMII-initialization/m-p/1448179)

上面链接遇到的问题在RGMII上跟现在比较相像，都是无法ping通，可惜nxp没有回复这个问题

[LS1046A custom board LSDK21.08 RGMII and SGMII not... - NXP Community](https://community.nxp.com/t5/Layerscape/LS1046A-custom-board-LSDK21-08-RGMII-and-SGMII-not-working/m-p/1615126)

```
cat /sys/class/net/fm1-mac3/mac_regs
```

上面链接问题在lsdk2108上同样出现，说明单纯更新lsdk不一定是能解决网络问题

[LS1046A RGMII->SGMII PHY linux device tree customi... - NXP Community](https://community.nxp.com/t5/QorIQ/LS1046A-RGMII-gt-SGMII-PHY-linux-device-tree-customization/m-p/1162134)

> SGMII is a MAC-PHY interface by it's definition. If you connect something else, the only available option is a [fixed-link](https://source.codeaurora.org/external/qoriq/qoriq-components/linux/tree/Documentation/devicetree/bindings/net/fixed-link.txt). In this mode, no externally connected PHY initialization is done, but the on-chip SerDes still expects that the connected device behaves as an SGMII PHY in terms of autonegotiation. If the connected device does not respond as a PHY, the link may fail. Changes in the driver code are required to adjust for other autonegotiation options. Details can be found in LS1046ARM, Section 31.8.1

上面链接提到可以使用fixed-link属性，在这种模式下，不进行外部连接的PHY初始化，但是片上SerDes仍然期望连接的设备在自动协商方面表现为SGMII PHY。如果连接的设备没有作为PHY响应，则可能导致链路故障。需要更改驱动程序代码以适应其他自动协商选项。但是我们这里都是有使用phy。

[SGMII connection with Marvel Phy - NXP Community](https://community.nxp.com/t5/QorIQ/SGMII-connection-with-Marvel-Phy/m-p/1256619)

> *Then run the following command to check whether you could get similar information.*
>
> 执行如下命令，查看是否有类似信息
>
> *=> mdio list
> FSL_MDIO0:
> 1 - RealTek RTL8211F <--> FM1@DTSEC3
> 2 - RealTek RTL8211F <--> FM1@DTSEC4
> FM_TGEC_MDIO:
> 1 - RealTek RTL8211F <--> FM1@DTSEC5
> 0 - RealTek RTL8211F <--> FM1@DTSEC6
> =>
> *
>
> *Then execute the following command to check the link status.*
>
> 然后执行如下命令检查链路状态
>
> *=> mdio read FM1@DTSEC5 1
> Reading from bus FSL_MDIO0
> PHY at address 1:
> 1 - 0x798d*
>
> *The link partner (“copper side”) link status bit is in Register #1 on the PHY. The 'Link Status' bit is bit #2 (from the left) of the last nibble. In the above example the nibble of interest is "d" (d = b'1101'), and therefore the 'Link Status' = 1, which means
> 'link up'. If the link were down this bit would be a "0," and we would see 0x7989.*
> 链路伙伴(“铜侧”)链路状态位位于PHY上的寄存器#1。“链接状态”位是最后一口的第2位(从左起)。在上面的示例中，感兴趣的小块是“d”(d = b'1101')，因此“Link Status”= 1，这意味着“连接”。如果链路断开，这个位将是“0”，我们将看到0x7989。

请参考以太网管理接口(EMI1/2)引脚终止检查表中的以下部分。

EMIx_MDC could be left unconnected since it is an output.

```
Connect MAC10 Ethernet interface to the server PC
b25805@star:/home/addon_4T/tftpboot/nxa22585/ls1046$ bft map -m 'LS1046ARDB-6_XFI2,lan10g' -c
Mapped:             LS1046ARDB-6_XFI2 -> lan10g (resource)
name: LS1046ARDB-6 | ip: 192.168.2.162 | mac: 00:e0:0c:00:8e:xx
LS1046ARDB-6_RGMII1         MRV6_1:17
LS1046ARDB-6_RGMII2         MRV6_1:18
LS1046ARDB-6_SD             SanDisk_16G
LS1046ARDB-6_SGMII1         MRV6_1:19
LS1046ARDB-6_SGMII2         MRV6_1:20
LS1046ARDB-6_Slot2_PCIe_NIC NW_1:27
LS1046ARDB-6_USB1           KingSton_16GB(USB3.0)
LS1046ARDB-6_USB2           KingSton_16GB(USB3.0)
LS1046ARDB-6_XFI1           LS1046ARDB-2_XFI1
LS1046ARDB-6_XFI2           bf-tg01_eth-10g-0
LS1046ARDB-6_serial0        OG_3:8
```

以下指令是查看PHY寄存器的命令，FM1@DTSEC3是设备名，第四位参数为偏移地址，当前为1，RTL8211fs手册中第50页，是BMSR寄存器，其中bit1.2能检查链路状态，输出如下，但是整个寄存器值都为0，说明存在问题，现在的链接状态应该是Not Linked，

```
=> mdio read FM1@DTSEC3 1
Reading from bus FSL_MDIO0
PHY at address 1:
1 - 0x0
```

在demoA上测试，由于未接入网线，所以当前为9

```
=> mdio read FM1@DTSEC5 1
Reading from bus FSL_MDIO0
PHY at address 1d:
1 - 0x7949
=> mdio read FM1@DTSEC6 1
Reading from bus FSL_MDIO0
PHY at address 1c:
1 - 0x7949
=> mdio read FM1@DTSEC10 1
Reading from bus FSL_MDIO0
PHY at address 1e:
1 - 0x7949
```

[Linux系统之phy芯片问题排查记录_phy芯片link不成功-CSDN博客](https://blog.csdn.net/qq_40177571/article/details/125719151)

[以太网PHY自学笔记 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/102296622)

[千兆PHY详解及调试举例-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1652191)

[phy芯片的千兆以太网的时钟传输方向_千兆phy芯片的时钟信号在哪-CSDN博客](https://blog.csdn.net/weixin_42066185/article/details/111247700)

[NXP LS1046平台的裕泰PHY芯片YT8521 YT8614调试笔记-CSDN博客](https://blog.csdn.net/Yangquot/article/details/131598026)

1.12

接下来将自研的RGMII等连到飞凌的PHY网口上测试，需要进行uboot上网口相关的修改

mac6  --  SGMII PHY1

[裕泰微YT8521SH PHY芯片在uboot下的代码适配（二）_zynq-linux适配 yt8531-CSDN博客](https://blog.csdn.net/qq_44710568/article/details/135285500)

参考以上链接，进行移植

移植完成，等周一烧录启动测试

下面链接是YT8531的

[motorcomm.c - drivers/net/phy/motorcomm.c - U-boot source code (v2023.10) - Bootlin](https://elixir.bootlin.com/u-boot/v2023.10/source/drivers/net/phy/motorcomm.c)

测试失败



断开飞凌板上的PHY后（断开mdc、mdio、TX、RX等线），mdio显示如下：

=> mdio list
FSL_MDIO0:
1 - YT8512 Ethernet <--> FM1@DTSEC3
2 - YT8512 Ethernet <--> FM1@DTSEC4
3 - YT8512 Ethernet <--> FM1@DTSEC5
FM_TGEC_MDIO:
2 - YT8512 Ethernet <--> FM1@DTSEC2

原本未断开时显示如下：

=> mdio list
FSL_MDIO0:
1 - YT8512 Ethernet <--> FM1@DTSEC3
2 - YT8512 Ethernet <--> FM1@DTSEC4
3 - YT8512 Ethernet <--> FM1@DTSEC5
FM_TGEC_MDIO:
1 - YT8512 Ethernet <--> FM1@DTSEC6
2 - YT8512 Ethernet <--> FM1@DTSEC2

自研断开PHY芯片电源后，不断开mdc、mdio、TX、RX等线时显示如下，还是能检测到有PHY

=> mdio list
FSL_MDIO0:
1 - Generic PHY <--> FM1@DTSEC3
2 - Generic PHY <--> FM1@DTSEC4
3 - Generic PHY <--> FM1@DTSEC9
FM_TGEC_MDIO:
4 - Generic PHY <--> FM1@DTSEC5
5 - Generic PHY <--> FM1@DTSEC6

[飞腾CPU FT-2000/4 uboot下PHY调试记录 - 乌拉大喵喵 - 博客园 (cnblogs.com)](https://www.cnblogs.com/wuladamiaomiao/p/17350591.html)

> FT2004C#mii dev
>
> MII devices: 'ethernet0@2820c000' 'ethernet1@28210000'
>
> Current device: 'ethernet0@2820c000'
>
> 可以看到当前使用的是第1个mac控制器。
>
> Mii info扫描：
>
> FT2004C#mii info
>
> PHY 0x04: OUI = 0x1374, Model = 0x07, Rev = 0x02, 10baseT, HDX
>
> 能够在这个mac下扫到一个地址为0x04的PHY，这个地址是通过PHY的管脚来配出来的。在mii info下能扫到这么一个PHY，说明mac的MDIO是通的。要是这里硬件上设计了一个PHY，但是这里没有扫到，那么就要去查硬件了，要是PHY都没扫到，后面测网络也白测。

>查看'ethernet0@2820c000'下PHY的link状态。
>
>使用mii dump命令可以查看phy的0~5的6个寄存器（使用mii read命令不存在这个说法，所有寄存器都能看 ）。因为我们的PHY地址是0x04，所以mii dump里的addr我们填0x04，reg部分我们从0填到5就能看全所有的寄存器了。现在是插着网线的，所以可以看到“(0004:0004) 1. 2   =   1   link status”表示link成功了，拔掉网线这里就=0了（(0004:0000) 1. 2   =   0  link status）。这也同时印证了PHY的MDIO是通的。还是那句话，这里的PHY link状态都读不到，那就去查硬件看看吧。MDIO都没通，不用着急去ping包。





|              | RDB1133_5559只烧录RCW时 | AFRWY3333_5559只烧录RCW时 | RDB1133_5559烧录firmware | AFRWY3333_5559烧录firmware |
| ------------ | ----------------------- | ------------------------- | ------------------------ | -------------------------- |
| 电流         | 0.3A                    | 0.9A                      | 0.3-0.6A                 | 0.9A                       |
| 打印信息     | 无                      | 无                        | 无                       | 正常信息                   |
| 系统是否启动 | 否                      | 否                        | 否                       | 是                         |



下午把通用驱动改成realtek的

#### 设置

```
setenv ipaddr 192.168.0.232
setenv serverip 192.168.0.100
setenv gatewayip 192.168.0.1
setenv netmask 255.255.0.0
setenv ethact FM1@DTSEC5
ping 192.168.0.100
mdio read FM1@DTSEC6 1
```



AFRWY测试

|                    | 原始镜像        | 修改后      |
| ------------------ | --------------- | ----------- |
| VSC8514_driver驱动 | 有              | 无          |
| 厂家id识别         | 正常识别        | 正常识别    |
| mdio list          | Vitesse VSC8514 | Generic PHY |
| ping主机           | 成功            | 失败        |

后面的厂家对应驱动不会去影响厂家id识别，依然能正常识别，但是通用的驱动不一定能驱动起来某些厂家的网口，前面厂家id识别失败，说明mdio或者phy存在问题，即是使用对应厂家的驱动来替换通用驱动进行初始化，也是无法驱动成功的，进行ping测试失败。



[【驱动】以太网扫盲（四）phy驱动link up流程分析 - 嵌入式与Linux那些事 - 博客园 (cnblogs.com)](https://www.cnblogs.com/dongxb/p/17365061.html)

u-boot/cmd/mii.c

```
if (op[0] == 'i') {
		unsigned char j, start, end;
		unsigned int oui;
		unsigned char model;
		unsigned char rev;

		/*
		 * Look for any and all PHYs.  Valid addresses are 0..31.
		 */
		if (argc >= 3) {
			start = addrlo; end = addrhi;
		} else {
			start = 0; end = 31;
		}

		for (j = start; j <= end; j++) {
			if (miiphy_info (devname, j, &oui, &model, &rev) == 0) {
				printf("PHY 0x%02X: "
					"OUI = 0x%04X, "
					"Model = 0x%02X, "
					"Rev = 0x%02X, "
					"%3dbase%s, %s\n",
					j, oui, model, rev,
					miiphy_speed (devname, j),
					miiphy_is_1000base_x (devname, j)
						? "X" : "T",
					(miiphy_duplex (devname, j) == FULL)
						? "FDX" : "HDX");
			}
		}
	}
```

u-boot/common/miiphyutil.c

```
int miiphy_info(const char *devname, unsigned char addr, unsigned int *oui,
		 unsigned char *model, unsigned char *rev)
{
	unsigned int reg = 0;
	unsigned short tmp;

	if (miiphy_read(devname, addr, MII_PHYSID2, &tmp) != 0) {
		debug("PHY ID register 2 read failed\n");
		return -1;
	}
	reg = tmp;

	debug("MII_PHYSID2 @ 0x%x = 0x%04x\n", addr, reg);

	if (reg == 0xFFFF) {
		/* No physical device present at this address */
		return -1;
	}

	if (miiphy_read(devname, addr, MII_PHYSID1, &tmp) != 0) {
		debug("PHY ID register 1 read failed\n");
		return -1;
	}
	reg |= tmp << 16;
	debug("PHY_PHYIDR[1,2] @ 0x%x = 0x%08x\n", addr, reg);

	*oui = (reg >> 10);
	*model = (unsigned char)((reg >> 4) & 0x0000003F);
	*rev = (unsigned char)(reg & 0x0000000F);
	return 0;
}
```

所以，其实miiphy_info这个函数运行是成功了的，只是获取的tmp以及被tmp更新的reg值都为0

根据给出的输出，每个PHY的OUI、Model和Rev的值都是0x0000、0x00和0x00。因此，根据miiphy_info函数中的解析过程：

- OUI的值是(reg >> 10)，即0x0000
- Model的值是(unsigned char)((reg >> 4) & 0x0000003F)，即0x00
- Rev的值是(unsigned char)(reg & 0x0000000F)，即0x00

因此，根据给出的输出，miiphy_info函数中的reg值应该是0x00000000。

说明miiphy_read获取的tmp值为0。

```
int miiphy_read(const char *devname, unsigned char addr, unsigned char reg,
		 unsigned short *value)
{
	struct mii_dev *bus;
	int ret;

	bus = miiphy_get_active_dev(devname);
	if (!bus)
		return 1;

	ret = bus->read(bus, addr, MDIO_DEVAD_NONE, reg);
	if (ret < 0)
		return 1;

	*value = (unsigned short)ret;
	return 0;
}

static struct mii_dev *miiphy_get_active_dev(const char *devname)
{
	/* If the current mii is the one we want, return it */
	if (current_mii)
		if (strcmp(current_mii->name, devname) == 0)
			return current_mii;

	/* Otherwise, set the active one to the one we want */
	if (miiphy_set_current_dev(devname))
		return NULL;
	else
		return current_mii;
}
```

u-boot/include/linux/mii.h

```
/* Generic MII registers. */
#define MII_BMCR		0x00	/* Basic mode control register */
#define MII_BMSR		0x01	/* Basic mode status register  */
#define MII_PHYSID1		0x02	/* PHYS ID 1                   */
#define MII_PHYSID2		0x03	/* PHYS ID 2                   */
```

u-boot/include/linux/mdio.h

```
#define MDIO_DEVAD_NONE			(-1)
```

根据uboot上的输出

```
=> mii device
MII devices: 'FSL_MDIO0' 'FM_TGEC_MDIO' 
Current device: 'FSL_MDIO0'
```

current_mii->name为FSL_MDIO0或者FM_TGEC_MDIO，这里是uboot中对应board初始化mdio总线时设置的，类似如下：u-boot/board/freescale/ls1046ardb/eth.c中

```
/* Register the 1G MDIO bus */
fm_memac_mdio_init(bis, &dtsec_mdio_info);
```

其中static struct mii_dev *current_mii;

```
struct mii_dev {
	struct list_head link;
	char name[MDIO_NAME_LEN];
	void *priv;
	int (*read)(struct mii_dev *bus, int addr, int devad, int reg);
	int (*write)(struct mii_dev *bus, int addr, int devad, int reg,
			u16 val);
	int (*reset)(struct mii_dev *bus);
	struct phy_device *phymap[PHY_MAX_ADDR];
	u32 phy_mask;
};
```

u-boot/drivers/net/fm/memac_phy.c

因为ls1046ardb配置了CONFIG_DM_ETH，所以配置了U_BOOT_DRIVER(fman_mdio)

```
static int fm_mdio_read(struct udevice *dev, int addr, int devad, int reg)
{
	struct mdio_perdev_priv *pdata = (dev) ? dev_get_uclass_priv(dev) :
						 NULL;

	if (pdata && pdata->mii_bus)
		return memac_mdio_read(pdata->mii_bus, addr, devad, reg);

	return -1;
}
```

fm_mdio_read本质上还是memac_mdio_read的封装。

因此bus->read(bus, addr, MDIO_DEVAD_NONE, reg);为 

fm_mdio_read(bus, addr, MDIO_DEVAD_NONE, reg);，然后为

memac_mdio_read(pdata->mii_bus, addr, MDIO_DEVAD_NONE, reg);

```
int memac_mdio_read(struct mii_dev *bus, int port_addr, int dev_addr,
			int regnum)
{
	struct memac_mdio_controller *regs;
	u32 mdio_ctl;
	u32 c45 = 1;
	int err;
	
	struct fm_mdio_priv *priv;

	if (!bus->priv)
		return -EINVAL;
	priv = dev_get_priv(bus->priv);
	regs = priv->regs;

	if (dev_addr == MDIO_DEVAD_NONE) {
		c45 = 0; /* clause 22 */
		dev_addr = regnum & 0x1f;
		memac_clrbits_32(&regs->mdio_stat, MDIO_STAT_ENC);
	} else
		memac_setbits_32(&regs->mdio_stat, MDIO_STAT_ENC);

	err = memac_wait_until_free(regs);
	if (err)
		return err;

	/* Set the Port and Device Addrs */
	mdio_ctl = MDIO_CTL_PORT_ADDR(port_addr) | MDIO_CTL_DEV_ADDR(dev_addr);
	memac_out_32(&regs->mdio_ctl, mdio_ctl);

	/* Set the register address */
	if (c45)
		memac_out_32(&regs->mdio_addr, regnum & 0xffff);

	err = memac_wait_until_free(regs);
	if (err)
		return err;

	/* Initiate the read */
	mdio_ctl |= MDIO_CTL_READ;
	memac_out_32(&regs->mdio_ctl, mdio_ctl);

	err = memac_wait_until_done(regs);
	if (err)
		return err;

	/* Return all Fs if nothing was there */
	if (memac_in_32(&regs->mdio_stat) & MDIO_STAT_RD_ER)
		return 0xffff;

	return memac_in_32(&regs->mdio_data) & 0xffff;
}
```

其中memac_in_32函数如下：

```
static u32 memac_in_32(u32 *reg)
{
#ifdef CONFIG_SYS_MEMAC_LITTLE_ENDIAN
	return in_le32(reg);
#else
	return in_be32(reg);
#endif
}
```

[linux内核：__user,__kernel,__safe,__force,__iomem_内核__user-CSDN博客](https://blog.csdn.net/Rong_Toa/article/details/86585086)

[内核IO操作函数 __raw_readl和__raw_writel-CSDN博客](https://blog.csdn.net/hunanchenxingyu/article/details/8932249#:~:text=__raw_readl和__raw_writel等是原始的操作I%2FO的方法，由此派生出来的操作方法有：inb、outb、_memcpy_fromio、readb、writeb、ioread8、iowrite8等。 空间的 以实现对 IO,空间的访问。 它主要用于处理 IO 设备数据的传输和处理。)

#### 1.22新发现

EM1和EM2在软件上是默认配置启用的，目前自研板硬件上使用的MDC/MDIO是EM1，但是EM1的MDC没有时钟波形，只有1.8V的电压，EM2则是有正确的方波波形。我们需要的是EM1能有正确的波形。

先把EM1的相关的电阻拆掉，看下没有其他影响的情况下，MDC波形能不能正确，如果还是无法正确，则可以试下改变接线使用EM2来读取。



1.23

把EM1的相关的电阻拆掉，看下没有其他影响的情况下，还是没有MDC波形

#### 问题解决（RGMII）

因为uboot蓝本使用afrwy的，所以定义了CONFIG_TARGET_LS1046AFRWY这个宏，这个宏会设置使用的EMI地址，是使用EMI1还EMI2

u-boot/include/fm_eth.h，可以修改如下

```
#ifdef CONFIG_SYS_FMAN_V3
#ifdef CONFIG_TARGET_LS1046AFRWY
//#define CONFIG_SYS_FM1_DTSEC_MDIO_ADDR	(CONFIG_SYS_FSL_FM1_ADDR + 0xfd000)
#define CONFIG_SYS_FM1_DTSEC_MDIO_ADDR	(CONFIG_SYS_FSL_FM1_ADDR + 0xfc000)
#else
#define CONFIG_SYS_FM1_DTSEC_MDIO_ADDR	(CONFIG_SYS_FSL_FM1_ADDR + 0xfc000)
#endif
#define CONFIG_SYS_FM1_TGEC_MDIO_ADDR	(CONFIG_SYS_FSL_FM1_ADDR + 0xfd000)
#if (CONFIG_SYS_NUM_FMAN == 2)
#define CONFIG_SYS_FM2_DTSEC_MDIO_ADDR	(CONFIG_SYS_FSL_FM2_ADDR + 0xfc000)
#define CONFIG_SYS_FM2_TGEC_MDIO_ADDR	(CONFIG_SYS_FSL_FM2_ADDR + 0xfd000)
#endif
#else
#define CONFIG_SYS_FM1_DTSEC1_MDIO_ADDR	(CONFIG_SYS_FSL_FM1_ADDR + 0xe1120)
#define CONFIG_SYS_FM1_TGEC_MDIO_ADDR	(CONFIG_SYS_FSL_FM1_ADDR + 0xf1000)
#endif
```

因为网络部分参考了ardb版本，而ardb版本两路EMI都使用了，其中EMI2使用连接万兆aqr113 PHY芯片，其余RGMII、SGMII连接到EMI1，但是自研板（当前配置使用了afrwy）不使用万兆aqr113 PHY芯片，所以才会出现mii info识别不到phy芯片，因为当前扫描的是EMI2，EMI2上确实没有PHY芯片

由硬件成员将某一个PHY芯片断开EMI1的连线，连接到EMI2的MDC/MDIO上，进行测试，能够识别到PHY芯片类似如下：

```
=> mii info
PHY 0x00: OUI = 0x0732, Model = 0x11, Rev = 0x06,  10baseT, HDX
PHY 0x01: OUI = 0x0732, Model = 0x11, Rev = 0x06,  10baseT, HDX
PHY 0x02: OUI = 0x0732, Model = 0x11, Rev = 0x06,  10baseT, HDX
PHY 0x03: OUI = 0x0732, Model = 0x11, Rev = 0x06,  10baseT, HDX
PHY 0x04: OUI = 0x0732, Model = 0x11, Rev = 0x06,  10baseT, HDX
PHY 0x05: OUI = 0x0732, Model = 0x11, Rev = 0x06, 100baseT, FDX
=> ping 192.168.0.100
Trying FM1@DTSEC5
eth_current->state: ETH_STATE_ACTIVE
Using FM1@DTSEC5 device

ARP Retry count exceeded; starting again
ping failed; host 192.168.0.100 is not alive
```

但是进行ping测试的时候还是失败

[解决问题（5）：成功解决uboot移植时网络通讯遇到的ARP Retry count exceeded； starting again_arp retry count exceeded; starting again-CSDN博客](https://blog.csdn.net/weixin_44903006/article/details/116205624)

[uboot网络操作解决：ARPRetry count exceeded； starting again ping failed； host 192.168.86.128 is not alive_arp retry count exceeded; starting again-CSDN博客](https://blog.csdn.net/qq_37619128/article/details/123360425)

[问题定位 uboot下无法ping通tftpserver_uboot下ping不通-CSDN博客](https://blog.csdn.net/shipinsky/article/details/120172497)

[U-boot 内的网络无法使用 - 昉·星光 （中文论坛） - RVspace Forum](https://forum.rvspace.org/t/u-boot/495/15)

排查电脑的环境变量，RGMII测试成功

```
=> mdio read FM1@DTSEC4 1
Reading from bus FSL_MDIO0
PHY at address 2:
1 - 0x79a9
=> mdio read FM1@DTSEC4 1
Reading from bus FSL_MDIO0
PHY at address 2:
1 - 0x79ad
=> setenv ethact FM1@DTSEC4
=> ping 192.168.0.100
Trying FM1@DTSEC4
eth_current->state: ETH_STATE_ACTIVE
Using FM1@DTSEC4 device
host 192.168.0.100 is alive
```

更换核心板测试RGMII，也是通的，有时候RGMII不通不清楚是什么环境引起的

```
=> ping 192.168.0.100
Trying FM1@DTSEC3
FM1@DTSEC3 Waiting for PHY auto negotiation to complete......... TIMEOUT !
FM1@DTSEC3: Could not initialize
FAIL
Trying FM1@DTSEC4
eth_current->state: ETH_STATE_ACTIVE
Using FM1@DTSEC4 device
host 192.168.0.100 is alive
```

后续进行测试的SGMII测试还是失败，还没有测试成功alive过

```
=> mdio read FM1@DTSEC6 1
Reading from bus FSL_MDIO0
PHY at address 5:
1 - 0x79a9
=>
Reading from bus FSL_MDIO0
PHY at address 5:
1 - 0x79ad
=> setenv ethact FM1@DTSEC6
=> ping 192.168.0.100
Trying FM1@DTSEC6
FM1@DTSEC6 Waiting for PHY auto negotiation to complete....... done
eth_current->state: ETH_STATE_ACTIVE
Using FM1@DTSEC6 device

ARP Retry count exceeded; starting again
ping failed; host 192.168.0.100 is not alive
```

#### SGMII调试

eth2aadr：c2:dd:f9:08:bc:cd

RDB板子上识别的时候，直接是千兆1000baseT，但是我们的板子能调通的RGMII和不能调通的SGMII都是百兆100baseT，瑞昱说的自协商应该是这部分的问题

```
=> mii info
PHY 0x00: OUI = 0x0732, Model = 0x11, Rev = 0x06,  10baseT, HDX
PHY 0x01: OUI = 0x0732, Model = 0x11, Rev = 0x06,  10baseT, HDX
PHY 0x02: OUI = 0x0732, Model = 0x11, Rev = 0x06, 1000baseT, FDX
PHY 0x03: OUI = 0x0732, Model = 0x11, Rev = 0x06,  10baseT, HDX
PHY 0x04: OUI = 0x0732, Model = 0x11, Rev = 0x06,  10baseT, HDX
```

RDB上MAC读取

```
=> mac
ID: NXID v1
SN: TR18300481
Errata: 1.0
Build date: 2018/08/06 13:35:38
Eth0: 00:04:9f:05:af:28
Eth1: 00:04:9f:05:af:29
Eth2: 00:04:9f:05:af:24
Eth3: 00:04:9f:05:af:25
Eth4: 00:04:9f:05:af:27
Eth5: 00:04:9f:05:af:26
CRC: 56124b9f
```

u-boot/cmd/net.c

```
#if defined(CONFIG_CMD_PING)
static int do_ping(struct cmd_tbl *cmdtp, int flag, int argc,
		   char *const argv[])
{
	if (argc < 2)
		return CMD_RET_USAGE;

	net_ping_ip = string_to_ip(argv[1]);
	if (net_ping_ip.s_addr == 0)
		return CMD_RET_USAGE;

	if (net_loop(PING) < 0) {
		printf("ping failed; host %s is not alive\n", argv[1]);
		return CMD_RET_FAILURE;
	}

	printf("host %s is alive\n", argv[1]);

	return CMD_RET_SUCCESS;
}
```

u-boot/net/arp.c

```
int arp_timeout_check(void)
{
	ulong t;

	if (!arp_is_waiting())
		return 0;

	t = get_timer(0);

	/* check for arp timeout */
	if ((t - arp_wait_timer_start) > ARP_TIMEOUT) {
		arp_wait_try++;

		if (arp_wait_try >= ARP_TIMEOUT_COUNT) {
			puts("\nARP Retry count exceeded; starting again\n");
			arp_wait_try = 0;
			net_set_state(NETLOOP_FAIL);
		} else {
			arp_wait_timer_start = t;
			arp_request();
		}
	}
	return 1;
}
```

1、请先确认下主机和虚拟机的网络设置，子网掩码等是否正确；
2、开发板直连电脑试下通不通；
3、使用wireshark抓包分析确认是发送问题还是对端接收问题；

[网络分析工具——WireShark的使用（超详细）-CSDN博客](https://blog.csdn.net/zzwwhhpp/article/details/113077747)



1046参考手册2141页MDIO_SGMII register descriptions



**Link Status**：Link状态指示位。Bit2=1代表端口Link up，0则代表端口Link down。实际应用中一般都是通过Bit2来判断端口的状态。而且，一般的MAC芯片也是通过轮询PHY的这个寄存器值来判断端口的Link状态的（这个过程可能有不同的名称，比如BCM叫做Link Scan，而Marvell叫做PHY Polling。）如前所述，**在AN Enable的情况下，Link Status的信息只有在Auto-Negotiation Complete指示已经完成的情况下才是正确可靠的，否则有可能出错。**

[自协商SGMII_板上调试篇_status_vector-CSDN博客](https://blog.csdn.net/weixin_39673080/article/details/86587406)







### WIFI驱动(已成功联网但板卡不稳定)

具体调试内容查看：`ls1046a驱动移植-WIFI.md`

识别设备接入->枚举->搜索选择驱动->使用驱动->驱动成功->显示新设备

#### 识别设备

原计划，是在飞凌板卡上验证然后再转到自研板卡，但是移远的fc6xe模块，跟飞凌板卡上使用的协议不一样（协议这里只涉及到蓝牙）

#### wifi模块fc6xe驱动

移远的文档上，提供了两部分的平台编译驱动，一是imx8q，二是ubuntu平台

##### imx8q平台

安装该流程编译，具体过程参考[四.编译Wi-Fi Driver(未完成)](###四.编译Wi-Fi Driver(未完成))，wlan_cnss_core_pcie.ko能编译生成，编译wlan.ko报错

报错相关一直是跟安卓上的代码相关，不清楚是4.14版本的问题还是什么，很多未定义的宏其实在nxp提供的最新的Linux6.1也是搜索不到，只有在[drivers/staging/qcacld-3.0/core/hdd/src/wlan_hdd_main.c - kernel/msm - Git at Google (googlesource.com)](https://android.googlesource.com/kernel/msm/+/android-msm-wahoo-4.4-oreo-m4/drivers/staging/qcacld-3.0/core/hdd/src/wlan_hdd_main.c)，这些类似的地方才能找到

##### ubuntu平台

双内核使用，手册上编译的ubuntu平台是使用grub在启动时选择对应的内核版本，偏向于PC使用的ubuntu系统，不是嵌入式板卡上uboot启动引导的ubuntu系统。

##### 后续

问移远，双内核能否在嵌入式平台上使用，怎么使用，然后最终是要编译生成驱动给wifi模块使用



##### 时序

软件方面需要控制的时序

| 名称          | 引脚     | 时间                                            | 电平   |
| ------------- | -------- | ----------------------------------------------- | ------ |
| WLAN_EN       | GPIO2 12 | 上电50us+4ms后                                  | 低->高 |
| BT_EN         | GPIO1 31 | 上电50us+4ms后                                  | 低->高 |
| PCIE_CLKREQ_N | GPIO2 13 | 上电50us+4ms后                                  | 高->低 |
| PCIE_RST_N    | GPIO2 15 | WLAN_EN等上面三个引脚时间进行电平变化大于15ms后 | 低->高 |

参考Documentation/devicetree/bindings/gpio/gpio.txt

0000 0000 0000 1101 0000 0000 0000 0000

0000 0000 0000 0010 0000 0000 0000 0000

0000 0000 0000 0000 0000 0000 0000 0001

##### 最终识别解决(2024.1.8)

时序问题解决，通过硬件电路上拉以及PCIE复位信号接入上电复位信号

硬件线序接反，SD2的TX和RX接反了

```
PCIe0: pcie@3400000 Root Complex: no link
PCIe1: pcie@3500000 Root Complex: no link
PCIe2: pcie@3600000 Root Complex: x1 gen2
```

#### 其他问题

在内核的.config文件中增加CONFIG_ONE_MSI_BUILD=y，然后回到wifi源码中重新编译

（wifi源码编译时会去读取内核的.config文件获取相关宏）

wlan_cnss_core_pcie.ko已经成功加载

wlan.ko加载失败，这里的驱动是能加载成功的

这里应该是硬件板卡不稳定，多次测试中有几次是成功加载的，并且能联网

已成功联网但不稳定(2024.1.9)



### eMMC驱动

eMMC 也是存储 Flash，相比 NAND Flash，eMMC 使用简单(和 SD 类似)、速度快、容量高。目前 eMMC 已经逐渐的取代了 NAND Flash

AMR控制器板载8G的eMMC

ls1046上使用的eSDHC控制器



| Block Base Address(Hex) | **Block**                                        | **CCSR configuration bus**          |
| ----------------------- | ------------------------------------------------ | ----------------------------------- |
| 156_0000 - 156_FFFF     | Enhanced Secured Digital Host Controller (eSDHC) | Big-endian (byte swapping required) |
|                         |                                                  |                                     |
|                         |                                                  |                                     |



修改例子：[【rk3568】uboot gpio寄存器配置_rk3568通过寄存器操作gpio-CSDN博客](https://blog.csdn.net/ldinvicible/article/details/131769320?spm=1001.2101.3001.6650.8&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-8-131769320-blog-131194883.235^v40^pc_relevant_3m_sort_dl_base4&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-8-131769320-blog-131194883.235^v40^pc_relevant_3m_sort_dl_base4&utm_relevant_index=15)

 四、GPIO4C6的地址就是sys_CRF+offset(0x74) = 0xFDC60074

需要将此地址中的10-8位设置为可写权限，也就是从图1手册中，设置为GPIO模式，

 writel(0x0700000,0xfdc60074);

10-8对应的在31-16中也就是0000 0111 0000 0000  | 0000 0000 0000 0000 也就是0x07000000



### NAND FLASH驱动





